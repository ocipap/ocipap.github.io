{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/analytics/google-analytics-4-debug-view/","title":"Google Analytics 4 Debug View"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Google Analytics 4 Debug View\ntags:\n  - analytics\n---\n\n웹 사이트를 구성하다보면 웹사이트나 앱의 트래픽 및 사용자 활동을 추적하고 분석하기위해 Google Analytics 라는 도구를 사용하개 된다.   \n그리고 여러 사용자 이벤트 추적을 통해 사용자의 행동 데이터를 수집하게 되는데, 데이터가 정상적으로 수집이 되고 있는지, 혹은 특정 이벤트가 울리지 않는 경우가 종종 발생한다.\n이때 google analytics 이벤트를 디버깅하는 방법중에 Debug View 가 있다.\n\n## Debug 모드 활성화 하는 방법\n\n1. Google Tag Manager 의 미리보기 모드를 통해 발생하는 모근 이벤트가 Debug 모드가 활성화 되어 있다. \n2. 미리보기가 아닌 상태에서 모든 이벤트를 디버깅하려면, Google Tag Manager 의 Google 태그 구성 태그의 구성 매개변수에 `debug_mode` 를 `true` 로 추가한다.  \n![](../attachments/.google-analytics-4-debug-view_images/GGaStjw10XfVHL15u0tAyWNmnmPu3tqakRNL.png)\n3. 미리보기가 아닌 상태에서 특정 이벤트를 디버깅하려면, Google Tag Manager 의 Google 태그 구성 태그의 구성 매개변수에 `debug_mode` 를 `true` 로 추가한다.\n![](../attachments/.google-analytics-4-debug-view_images/CleanShot 2024-02-21 at 21.png)\n\n\n## Debug View\nDebug 모드가 활성화 되면, Google Analytics 4 Debug View 에서 이벤트를 확인할 수 있다.\n![](../attachments/.google-analytics-4-debug-view_images/CleanShot%202024-02-21-10-08.png)\n\n![](../attachments/.google-analytics-4-debug-view_images/CleanShot 2024-02-21 at 22.png)\n\n수집되는 이벤트 이름 뿐만 아니라, 해당 이벤트가 수집되었을때 파라미터, 사용자 속성 등을 함께 확인할 수 있다.\n\n## 참고 자료\n- https://support.google.com/analytics/answer/7201382?hl=en\n\n\n"},{"fields":{"slug":"/","title":"PAPICO WIKI"},"frontmatter":{"draft":false},"rawBody":"# PAPICO WIKI\n\n잘 기록해보자구 ٩(ᐛ)و "},{"fields":{"slug":"/analytics/hotjar/","title":"hotjar"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: hotjar\ntags:\n  - analytics\n---\n\n웹사이트 동적 분석 툴, Heatmaps, Recordings 등등 다양한 기능을 제공한다.\n\n## with GTM\ngtm 을 통해 hotjar 를 install 할 수 있다.\n\n- [Getting Started with Google Tag Manager and Hotjar](https://help.hotjar.com/hc/en-us/articles/6568578099991)  \n- [Google Tag Manager Installation Troubleshooting](https://help.hotjar.com/hc/en-us/articles/360016229274)\n- [How to Send User Attributes with Google Tag Manager](https://help.hotjar.com/hc/en-us/articles/6597875033751)\n\n\n\n"},{"fields":{"slug":"/book/Clean Code/","title":"Clean Code"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Clean Code\ntags:\n  - 독서\n---\n\n도서 링크: https://www.yes24.com/Product/Goods/11681152\n\n![CLean Code](https://image.yes24.com/goods/11681152/L)\n\n\n## 함수\n\n**느낀점**\n처음부터 완벽한 규칙기반의 함수를 작성하는 것은 무리가 있다.  \n노하우가 쌓여간다면, 누구나 읽기 쉬운 함수를 작성할 수 있을 것 같다.\n\n### 작게 만들기\n\n함수는 가능한 하나의 역할만 하도록 만든다.\n\n### switch 문은 사용을 지양한다.\n\n하지만 불가피하게 사용할 수 밖에 없는 상황이 존재한다.\n그렇다면 다형성적 객체를 생성하는 코드안에서 사용한다.\n\n### 서술적인 이름을 사용한다.\n\n한가지 역할만 하면서 함수의 이름이 해당 코드를 설명하면, 가장 좋은 케이스\n이름을 지을때는 일관적인 이름을 사용해야한다.\n\n예를 등어 생성이라고 하는 동작을 create, add 등 다양하게 사용할 수 있지만, 해당 프로젝트에서 사용하는 규칙을 정해서 하나만 사용하는 것이 좋다.\n\n### 함수의 인수\n\n**플래그 인수**  \n함수에 boolean 값을 넘긴다는 것 자체가 이미 해당 함수가 2가지 일을 하고 있는 것, 참일때 로직, 거짓일때 로직\n\n**함수에 인수 관련 키워드 추가하기**\n함수를 작성하다보면 인수의 순서가 헷갈릴 수 있는데, 함수에서 해당 인수의 순서를 명확하게 드러내는 방법또한 존재한다.\n\n### 부수효과를 일으키지 않는다.\n\n책의 예제에서는 checkPassword 로직에서 user 의 세션을 날려버린다.\n이렇게 되면 세션을 날려도 괜찮은 부분에서만 checkPassword 를 사용할 수 있다.\n부수효과는 의도하지 않는 상황을 일으킨다.\n\n### 오류 코드 분기 보다 예외를 사용한다.\n\n오류 처리 로직을 분리해서 본문 코드가 깔끔해진다.\ntry/catch 를 별도 함수로 뽑아서 사용하면, 하나의 함수에서 오류에 대한 처리를 하기 때문에, 로직을 이해하기 쉬워진다.\n\n### 반복하지 않는다.\n\n반복은 코드의 길이를 늘리고, 알고리즘이 변하면 네곳을 수정해야한다.\n\n## 주석\n\n**느낀점**\n\n### 주석은 거의 대부분 불필요하다.\n\n경솔하고 근거없는 주석은 코드를 이해하기 어렵게 만든다. 주석은 언제나 실패를 의미한다\n프로그래머들이 주석을 유지 보수하기는 현실적으로 불가능하다.\n\n### 좋은 주석\n\n주석은 가능한 사용하지 않으면 좋지만, 불가피한 상황에 사용하는 경우가 있다.  \n\n**위 예시 외에 거의 모든 주석은 코드로 해결가능하다.**\n\n## 6. 객체와 자료구조\n"},{"fields":{"slug":"/book/Five Lines of Code/","title":"Five Lines of Code"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Five Lines of Code\ntags:\n  - 독서\n---\n\n도서 링크: https://www.yes24.com/Product/Goods/116904325\n\n![Five Lines of Code](https://image.yes24.com/goods/116904325/L)\n\n\n## 3장. 긴 코드 조각 내기\n\n### DRY 및 KISS 지침들이 어려웠던 이유\n- 메서드가 여러가지 다른 일을 수행한다.\n- 낮은 수준의 원시 연산을 사용한다.\n- 주석과 적절한 메서드와 변수명 같이 사람이 읽을 수 있는 텍스트가 부족하다.\n\n### 왜 다섯 줄인가?\n정의: 메서드는 `{` 와 `}` 를 제외하고 5줄 이상이 되어서는 안 된다.\n\n모든 메서드를 이 규칙을 준수하도록 바꿀 수 있다.\n\n**스멜**  \n메서드가 길다는 것 자체가 스멜이다. 긴 메서드의 모든 논리를 머릿속에 담아야해서 작업하기가 어렵다. \n\n**의도**  \n시간이 지남에 따라 추가되는 기능들로 인해 메서드가 커지는 경향이 있다. 5줄의 코드가 있는 4개의 메서드가 20줄인 하나의 메서드보다 훨씬 빠르고 이해하기 쉽다.\n\n코드를 이해하기 위한 첫 번째 단계는 **항상 함수명을 고려하는 것**  \n\n### 리펙터링: 메서드 추출\n메서드를 더 작은 조각으로 분해하는 리팩터링 기법이다.\n\n- 원하는 이름으로 새로운 빈 메서드 생성\n- 그룹의 맨 위에서 새로운 메서드 호출\n- 그룹의 코드를 잘라내어 새로운 메서드의 본문에 붙여 넣기\n- 컴파일\n- 메개변수를 도입하여 호출하는 쪽의 오류를 발생시키기\n- 매개변수 중 하나를 반환값으로 할당해야 할 경우: \n  - 새로운 메서드의 마지막에 반환값을 추가\n  - 새로운 메서드를 호출하는 쪽에서 반환값을 할당\n- 컴파일\n- 호출쪽 인자 셋팅\n- 사용하지 않는 코드와 주석 제거\n\n이 절차는 아무것도 손상시키지 않는다. 코드가 수행하는 작업을 아직 살펴보지 않는 경우에는 아무것도 고장내지 않았다는 확신이 가장 중요함\n\n### 규칙: 호출 또는 전달, 한 가지만 할 것  \n함수 내에서는 객체에 있는 메서드를 호출하거나 객체를 인자로 전달할 수 있지만 둘을 섞어 사용해서는 안된다.  \n많은 메서드 및 여러 가지 매개변수를 전달하는 경우, 결국 해당 함수의 책임이 고르지 않게 될 수 있다.  \n\n```ts\nfunction average(arr: number[]) {\n  return sum(arr) / arr.length\n}\n\n\nfunction average(arr: number[]) {\n  return sum(arr) / size(arr)\n}\n```\n위 함수는 높은 수준의 추상화와 낮은 수준의 arr.length 를 모두 사용\n\n**스멜**  \n함수의 내용은 동일한 추상화 수준에 있어야 한다. 전달된 인자의 메서드가 어떻게 사용되는지 식별하는 방ㄹ법은 인자로 전달된 변수 옆의 `.` 을 통해 찾을 수 있다. \n\n**의도**  \n메서드에서 몇 가지 세부적인 부분을 추출해서 추상화를 도입할 때 연관된 다른 세부적인 부분도 추출하게 한다. 이러면 메서드 내부의 추상화 수준이 항상 동일하게 유지  \n> 함수의 내용은 동일한 추상화 수준에 있어야 한다.\n\n### 좋은 함수의 이름의 속성\n- 정직해야 한다. 함수의 의도를 설명해야 한다. \n- 완전해야 한다. 함수가 하는 모든 것을 담아야 한다.\n- 도메인에서 일하는 사람이 이해할 수 있어야 한다. \n\n> 함수명을 지을 때는 항상 나중에 함수가 더 작아졌을 때 이름을 개선할 수 있는지를 평가해 봐야한다. \n\n### 규칙: if 문은 함수의 시작에만 배치\nif 문이 있는 경우 해당 if 문은 함수의 첫번째 항목이어야 한다.  \n함수는 한 가지 일만 해야 한다. 무언가를 확인하는 것은 한가지 일 즉 if 가 있는 경우 함수의 첫번째 항목이어야 하고, 그 후에는 아무것도 해서는 안된다.  \nif 문을 분리하가 위해 메서드 추출을 사용한다.  \n\n```ts\nfunction reportPrimes(n: number) {\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      console.log(`${i} is prime`);\n    }\n  }\n}\n\n\nfunction reportPrimes(n: number) {\n  for (let i = 2; i < n; i++) {\n    reportIfPrime(i);\n  }\n}\n\nfunction reportIfPrime(n: number) {\n  if (isPrime(i)) {\n    console.log(`${i} is prime`);\n  }\n}\n```\n\n**스멜**  \n다섯 줄 제한과 같이 이 규칙은 함수가 한가지 이상의 작업을 수행하는 스멜을 막기 위해 존재\n\n**의도**  \nif 문이 하나의 작업이기 때문에 이를 분리할 때 이어지는 else if 는 if 문과 분리할 수 없는 원자 단위로 봄\n\n## 4장. 타입 코드 처리하기\n\n### 규칙: if 문에서 else 를 사용하지 말 것\n\n프로그램에서 이해하지 못하는 타입인지를 검사하지 않는 한 if 문에서 else 를 사용하지 않는다.\n\n`if-else` 를 사용하면 코드에서 결정이 내려지는 지점을 고정하게 된다.\n\n독립된 if 문은 검사로 간주하고, if-else 문은 의사 결정으로 간주한다.\n\n```ts\n// AS IS\nfunction average(ar: number[]) {\n  if (size(ar) === 0) {\n    throw new Error(\"Cannot take average of empty array\");\n  }\n  return sum(ar) / size(ar);\n}\n\n// TO BE\nfunction average(ar: number[]) {\n  assertNotEmpty(ar);\n  return sum(ar) / size(ar);\n}\n\nfunction assertNotEmpty(ar: number[]) {\n  if (size(ar) === 0) {\n    throw new Error(\"Cannot take average of empty array\");\n  }\n}\n```\n\n**스멜**  \n이른 바인딩: if-else 같은 의사결정 동작은 컴파일 시 처리되어 애플리케이션에 고정되면 재컴파일 없이는 수정할 수 없다.  \n늦은 바인딩:  코드가 실행되는 순간 동작이 결정됨\n\n**의도**  \nif 는 흐름을 제어 -> 다음에 실행할 코드를 결정한다는 뜻  \n\n### 리펙터링: 클래스로 타입 코드 대체\n열거형을 인터페이스로 변환하고 열거형의 값들을 클래스가 되도록 변환한다.  \n해당 리펙터링 패턴은 자체적으로 많은 가치를 가지지 않지만, 추후 개선을 가능하기 한다.\n\n### 리펙터링: 클래스로 코드 이관하기  \n기능을 클래스로 옮기면서 클래스로 타입 코드 대체 패턴의 자연스러운 연장선  \n특정 값과 연결된 기능이 값에 해당하는 클래스로 이동하기 때문에 불변속성을 지역화  \n\n### 리펙터링: 메서드의 인라인화 \n프로그앰에서 더 이상 가독성에 도움이 되지 않는 메서드를 제거   \n단, 메서드를 인라인으,로 사용하는 것과는 다른 개념  \n\n메서드가 인라인화 하기 너무 복잡한가 -> 낮은 수준의 연산에 의존하여 가독성에 도움이 되는 경우에는 인라인화하지 않는다.  \n\n### 리펙터링: 메서드 전문화  \n일반화하고 재사용하려는 본능적인 욕구가 있지만 그렇게 하면 책임이 흐려지고, 다양한 위치에서 코드를 호출할 수 있기 때문에 문제가 될 수 있음  \n전문화된 메서드는 더 적은 위치에서 호출되어 필요성이 없어지면 더 쉽게 제거 가능함  \n\n### 규칙: switch 를 사용하지 말것\ndefault 케이스가 없고 모든 case 에 반환값이 존재하는 경우에는 switch 를 사용하지 않는다.\n\n**switch 의 문제점**\n- 컴파일러 입장에서 새로 추가한값의 처리에 대한 누락을 알 수 없다.\n- break 키워드 누락으로 인한 버그\n\n**스멜**  \nswitch 문은 값을 처리하는 방법에 초점, 클래스에 기능을 추가할때는 값이 상황을 처리하는 방법에 초점  \n컨텍스트에 초점을 맞춘다는 것은 불변속성을 전역화하는 것을 의미  \n\n**의도**  \nswitch -> else if -> 클래스로 변환\n\n### 인터페이스 대신 추상 클래스를 사용할 수 없을까?  \n사용할 수 있다. 코드의 중복을 피할 수 있다.   \n하지만 인터페이스를 사용하면 개발자가 능동적으로 무엇인가를 해야함. 즉, 누락으로 인한 오류를 방지할 수 있음\n\n### 규칙: 인터페이스에서만 상속받을 것  \n상속은 오직 인터페이스를 통해서만 받는다.  \n\n추상 클래스를 사용하는 것은 일부 메서드의 기본 구현을 제공하고, 다른 메서드를 추상화 하기 위함 -> 중복을 줄이고 코드의 줄을 줄이고자 할 경우 편리  \n하지만 추상 클래스의 코드 공유는 커플링을 유발하고, 기본 구현으로 인해 재정의가 필요한 메서드 인지 컴파일러를 통해 확인이 어려움 \n\n**스멜**  \n> 상속보다는 컴포지션이 더 좋다 <<GoF의 디자인 패턴>>  \n\n### 리팩터링: 삭제 후 컴파일하기\n인터페이스에서 사용하지 않는 메서드를 제거하는 것  \n메서드를 삭제하고 컴파일러에서 허용하는지 확인하는 것  \n\n## 5장. 유사한 코드 융합하기  \n\n### 리팩터링: 유사 클래스 통합  \n일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서 일련의 상수 메서드가 클래스에 따라 다른 값을 반환할 때 클래스를 통합할 수 있다.   \n\n### 리펙터링: if 문 결합\n동일한 연속적인 if 문을 결합해서 중복을 제거  \n\n### 규칙: 순수 조건 사용  \n조건에 부수적인 동작이 없음을 의미  \n**부수적인 동작**: 조건이 변수에 값을 할당하거나 예외를 발생시키거나, 출력, 파일 쓰기 등과 같은 I/O 와 상호작용 하는 것을 의미  \n\n**스멜**  \n> 명령에서 질의 분리  \n\n명령은 부작용이 있는 모든 것을 의미, 질의는 순수한 것을 의미  \nvoid 메서드에서는 부수적인 동작을 허용, 즉 부수적인 동작을 하거나 or 값을 반환하거나 둘 중 하나만 하는 형태  \n\n**의도**  \n데이터를 가져오는 것과 변경하는 것을 분리하는 것 -> 코드를 깔끔하고 예측 가능하게 만들어줌  \n\n### 클래스 다이어그램  \n인터페이스와 클래스의 구조가 서로 어떤 관계가 있는지 보여줌  \n클래스의 공용 인터페이스에 관심이 있어서, 비공개 항목은 포함하지 않음  \n\n클래스와 인터페이스의 관계  \n- X가 Y를 사용한다. (Uses a) -> 의존, 연관\n- X는 Y다. (is a) -> 상속, 구현\n- X가 하나 또는 여러개의 Y를 가진다. (Has a) -> 집합, 컴포지션\n\n인터페이스에서만 상속받을 것이라는 규칙으로 인해 상속은 사용 X, 의존, 연관 관계는 관계가 무엇인지 모르거나 신경쓰지 않을때 사용, 컴포지션과, 집합의 차이는 어떻게 표현하는가의 문제 (동일)  \n따라서 대부분 **컴포지션**과 **구현**, 두 가지 관계 유형을 사용  \n\n### 리팩터링: 전략 패턴의 도입  \n전략 패턴: 다른 클래스를 인스턴스화해서 변형을 도입하는 개념  \n전략 패턴을 도입하는 상황  \n- 코드에 변형을 도입하고 싶어서 리펙터링을 수행하는 경우  \n- 떨어지는 성질을 코드화했던 상황에서 바로 변형의 추가가 필요하다고 예상하지 않았을 때 \n\n## 10장. 코드 추가에 대한 두려움 떨쳐내기 \n\n### 불확실성 받아들이기: 위험 감수  \n겁을 먹으면 효과적으로 일할 수 없다. 소프트웨어 개발은 도메인을 학습하고 그 지식을 프로그래밍 언어로 코드화 하는 것  \n그 과정중에는 용기가 필요하다.  \n우리는 불확실한 영역을 두려워할 때가 많지만 그 영역이 우리가 배워야 할 부분  \n> 위험에 뛰어들라  \n\n두려움은 심리적 고통의 한 형태, 뭔가 두렵다면 더 이상 두렵지 않을 때까지 더 시도  \n\n### 스파이크를 사용한 두려움 극복  \n스파이크: 프로젝트 초기에 스토리를 진행하기 앞서 사용할 기술(라이브러리, 프레임워크)을 조사하고, 요구사항에 관련된 배경지식을 습득하는 단계  \n스파이크가 제품의 코드나 기능이 아닌 지식이라는 것을 인지할 필요가 있음  \n스파이크가 제품의 코드라는 생각이 들면, 프로덕션을 위한 코드를 작성하는 것과 같은 두려움이 커질 수 있음  \n스파이크를 통해 얻은 지식을 문서화하여 이해관계자, 팀원들과 공유하는 것이 중요  \n\n### 두려움 극복을 위한 사용 시간 비율 지정  \n프로적션 코드와 지원 도구 사이의 합리적인 복잡성 비율 80:20  \n이해관계자의 요청에 의해 발생되지 않는 모든 작업을 금요일에 몰아서 하는 방법도 효율적  \n금요일에는 주로 실험하거나, 리펙토링, 개발 작업을 자동화하는 작업을 수행  \n\n### 점진적 개선  \n가면 증후군: 스스로를 자격이 없는 사람으로 간주하여 누군가 자신을 사기꾼으로 폭로할까 봐 두려워하는 것  \n개발자들은 종종 다른 사람의 코드를 경솔하게 비판 -> 이는 가면 증후군을 불러일으킴  \n완벽한 코드는 존재하지 않음. 무엇에 초점을 맞출 것인지, 그리고 어디에서 불완전함을 받아들일 것인지 선택해야함\n\n### 복제된 코드가 속도에 미치는 영향  \n코드를 공유하면 코드가 사용되는 모든 위치에 영향을 미치기 쉽다.  \n코드를 공유하면 전역적인 동작 변경 속도가 증가하고, 코드를 복제하면 지역적인 동작 변경 속도가 증가한다.  \n\n전역적인 동작 변경 속도가 높다는 것은 -> 코드상으로 관련이 없어 보이는 부분에도 영향을 미친다는 것: **취약성**  \n\n> \"이것을 원본과 결합해야 하는가?\"  \n> \"복사본이 바뀌면 원본이 바뀌어야 하는가?\"  \n> \"팀이 통합된 코드를 가지고 있는가?\"\n\n위 질문에 답이 \"아니요\" 인 경우에는 복제되어 관리되는 것이 좋음\n\n### 확장성을 통한 추가에 의한 변경  \n모든 것을 확장가능하게 만ㄷ그는 것은 코드를 불필요하게 복잡하게 만듦  \n우발적 복잡성: 도메인에 관련되지 않은 복잡성  \n본질적 복잡성: 코드가 실제 세계를 나타내면서 상속된 일부 복잡성  \n\n우발적 복잡성을 없애기 위한 세가지 단계  \n1. 코드를 복사  \n2. 복사본을 이용해 작업  \n3. 합리적이라는 판단하에 원본과 통합  \n\n리펙토링 패턴 중 확장-수축 패턴과 유사  \n\n### 추가에 의한 변경으로 이전 버전과의 호환성 확보  \n이전 기능들이 동작하는 형태로 새로운 기능 추가  \n\n### 기능 플래그를 통한 변경  \n기능플래그를 통해 지속적으로 프로덕션에 나가는 환경 구성 \n프로적션에 100% 서빙된 기능 플래그는 제거해야함   \n**추상화를 통한 분기**: 기능플래그가 true, false 가 아닌 NewA, OldA 같은 것으로 반환되게 하는 것 \n\n## 11장. 코드 구조 따르기 \n\n### 범위와 출처에 따른 구조 분류\n\n|           | 팀 간    | 팀 내          |\n|-----------|--------|--------------|\n| 코드에 있는 경우 | 외부 API | 데이터와 함수, 대부분의 리펙토링 |\n| 사람에 있는 경우 | 조직도, 프로세스 | 행위 및 도메인 전문가 |  \n\n조직 구성과 그 조직이 만든 시스템 구조는 닮는 경향이 있다. -> 콘웨이 법칙  \n\n### 행위를 코드화하는 세가지 방법\n- 제어 흐름  \n- 데이터 구조  \n- 데이터 자체  \n\n\n### 제어 흐름에 행위 코드화하기  \n제어 흐름은 제어 연산자. 메서드 호출, 또는 열거된 코드의 줄을 통해 행위를 텍스트로 표현  \n제어 흐흠 안에 행위를 기술하면 커다란 변화를 만들기 쉬움 \n안정성과 작은 변화를 선호하기 때문에 제어 흐름을 사용해 리펙터링하지 않음  \n그러나 어떤 상황에서는 큰 조정이 필요한 경우가 있기 때문에 제어 흐름으로 리펙터링 후, 다시 리펙터링 하는 것도 유용할 수 있음  \n\n### 데이터 구조에 행위 코드화 하기\n데이터 구조에 행위 코드화 변형점과 일치하지 않는 한 큰 변경을 수행하기 어려움. 그러나 작은 변경은 쉽고 안전함  \n클래스로 타입 코드 대체, 전략 패턴 도입 리펙터링 패턴 모두 제어 흐름을 데이터 구조로 옮긴 것  \n\n### 데이터에 행위 코드화 하기  \n컴파일러의 지원을 받지 못하기 때문에 안전하게 사용하는 것이 어려움, 비추  \n\n### 구조 노출을 위한 코드 추가  \n우리는 소프트웨어를 올바르다고 믿는 특정한 방향으로 변경하기 위해 리펙터링을 사용  \n주변에 참고할 코드가 많을 수록 이 방향의 코드와 데이터가 많이 있기 때문에 코드가 어떻게 변경될지 알 가능성이 높음  \n기본 구조에 대한 확신이 없다면 리펙터링 노력을 줄이고 정확성에 집중해야 함  \n새로운 기능이나 하위 시스템을 구현할 때는 불확실성이 있기 때문에 이럴때는 클래스보다 열거형이나, 루프를 사용하는 것이 좋음  \n즉 상황에 맞춰서 하는 것이 좋다는 뜻  \n\n### 예측 대신 관찰, 그리고 경험적 기술 사용  \n예측하려는 시도는 코드베이스레 도움이 되기보다는 손상을 줄수 있음  \n코드를 추측하지 말고 경험적인 기술을 사용해야함  \n\n- 변경되지 않으면 아무것도 하지 마십시오. \n- 예측할 수 없이 변경되는 경우 취약성을 피하기 위해서만 리펙터링하시오. \n- 그렇지 않으면, 과거에 발생한 변경 유형을 적용해 리펙터링하시오.  \n\n### 코드를 이해하지 않고도 안정성을 확보하는 방안  \n이미 코드에 있는ㄴ 구조를 따르고 실수 없는 믿을만한 리펙터링 패턴을 사용하는 한 작업을 위해 코드를 이해할 필요 없음  \n- 테스트를 통한 안정성 확보\n- 숙달을 통한 안정성 확보  \n- 도구의 지원을 통한 안정성 확보  \n- 공식 인증을 통한 안정성 확보  \n- 내결함성을 통한 안정성 확보  \n\n\n### 활용되지 않은 구조 이용  \n우연이거나 일시적인 구조를 이용하는 것은 속도 저하로 이어질 수 있음   \n도메인으로부터 온 구조는 흔히 안전하게 활용할 수 있음  \n구조가 활용 가치가 있는지를 결정하기 전에 먼저 구조를 찾아야 함  \n\n### 추출 및 캡슐화에 공백 활용  \n개발자는 머릿속에서 그룹화하기 때문에 빈 줄을 사용해서 지각된 구조를 표현할 때가 많음  \n사이에 공백을 넣어 그룹화된 되어 있는 경우 -> 메서드 추출 패턴을 생각해봐야 함  \n공백의 일반적인 위치는 필드를 그룹화하는 데 사용되는 경우 -> 데이터 캡슐화 리펙터링 패턴을 생각해봐야 함\n\n### 통합에 중복 코드 활용  \n코드 중복에 대해 통합을 적용 시킬 수 있음  \n\n- 메서드 추출  \n- 메서드 캡슐화  \n- 유사 클래스 통합  \n- 전략 패턴 도입\n\n리펙토링 패턴을 이용하면 구조가 숨겨져 있는 경우에도 해당 구조를 노출할 수 있음  \n\n### 캡슐화로 공통 접사 활용  \n공백이나 중복, 또는 이름의 공통적인 명칭을 통해 그룹화된 것을 발견할 때 이 구조를 견고하게 하는 방법은 **데이터 캡슐화**  \n유사한 이름을 가진 클래스들을 그룹화하는 데도 해당 규칙이 사용될 수 있음  \n언어만다 지원하는 방식이 다르지만, TS 에서는 namespace 모듈을 사용함  \n\n### 동적 실행으로 런타임 유형 활용  \n객체지향 프로그래밍은 인터페이스를 통한 동적 실행이라는 강력한 매커니즘이 내장되어 있기 때문에 런타임 타입을 검사하는 기능 업싱 고안  \n\n두 가지 타입 (A, B)을 가질 수 있는 변수가 있다고 가정했을때, 보통은 현재 타입을 직접 검사해서 적절한 동작을 수행\n- 만약 A 와 B 를 통제할 수 있는 경우 \n  - 이러한 경우에는 클래스로 코드 이관을 통해서 새로운 인터페이스를 만들고, 변수를 이 타입을 가지도록 변경한 후 두 클래스가 모두 인터페이스를 구현하도록 함\n- 만약 A 와 B 를 통제할 수 없는 경우 \n  - 코드베이스가 오염되지 않도록 타입 검사를 코드의 가장자리에 위치  \n\n\n\n\n"},{"fields":{"slug":"/book/모든 것이 되는 법/","title":"모든 것이 되는 법"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 모든 것이 되는 법\ntags:\n  - 독서\n---\n도서 링크: https://www.yes24.com/Product/Goods/57445016  \n\n![모든 것이 되는 법](https://image.yes24.com/goods/57445016/L)\n\n하고 싶은 것이 너무 많았다. 하지만 무엇부터 해야할 지, 한정된 시간동안 내가 하고 싶은 것을 다 할 수 있을지가 막막했다. \n이 고민을 PO 분께 말씀드렸더니, 이 책을 추천해주셨다.\n이름부터 **모든 것이 되는 법** 확 끌렸다.\n\n나는 어떤 분야에 쉽게 흥미를 가지지만, 금방 해당 분야에 대한 흥미가 떨어지는 편이다. 그리고 그 동시에 또 새로운 것에 관심이 생긴다.\n이런 내 모습에서 나는 과연 전문가가 될 수 있을까? 라는 의문이 생긴다.\n어쩌면 수박겉핥기 식으로 여러 분야만 찍어먹어보다가, 나중에 시간이 지났을 때 이미 한 분야에 전문가가 되어 있는 다른 사람들을 보면서 후회하는 삶을 사는 것이 아닌가 라는 걱정이 크다.\n\n이 책에서는 다능인 이라는 표현을 많이 나온다. \"다양한 호기심과 열정으로 자신만의 길을 걷는 사람들\" \n솔직히 처음 이 표현을 봤을때는 그냥 단순히 산만한 사람을 보기 좋게 포장하는구나 라고 생각했다.\n하지만 책을 읽으면 읽을수록 조금씩 생각이 달라졌다. 조금 더 효과적으로 다양한 호기심을 유지할 수 있는 전략을 알려주었다. \n\n이중 직업모델중에 하나인 아인슈타인 접근법이 내가 추구하는 것에 가까웠다.\n아인슈타인 접근법은 안정적인 수입을 제공하는 직업이 있고, 저녁 시간이나 여가 시간에 자신이 하고 싶은 관심사를 실현하는 것이다. 이때 다른 열정들에 힘을 쏟을 수 있는 충분한 시간과 에너지를 남겨두어야 한다.\n이 방법은 다양한 것을 하고 싶어하는 사람들의 가장 큰 고민거리인 수입에 대한 안정성을 보장하고, 직업과 관계없는 다른 관심사를 수입으로 부터 자유롭게 해준다.\n\n그리고 이 책의 8장에서 소개하는 나만의 시스템 만들기의 4단계인  \n- 무엇에 집중할 것인지 결정하기\n- 시간 만들기\n- 그만둘 때를 알기\n- 일을 시작하기\n는 각각의 단계에서 고려해야할 것들과, 사례를 들어 설명해준다. 이 단계를 통해 내가 하고 싶은 것중에 지금 당장 할 수 있는 것 or 하고 싶은 것이 무엇인지, 또 그 일들을 어느 시간때에 할 수 있는지, 그리고 그 흥미를 언제까지 이어나갈 수 있는지에 대한 기준등을 잡고 결정할 수 있었다.\n\n솔직히 아직도 확신이 안서는 것은 있다. 그리고 이 책을 읽고 난 뒤의 나의 삶또한 그렇게 크게 변한 것같지는 않다. 하지만 조바심은 많이 줄어든 것 같다. \n\n\n\n\n"},{"fields":{"slug":"/book/쏙쏙 들어오는 함수형 코딩/","title":"쏙쏙 들어오는 함수형 코딩"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 쏙쏙 들어오는 함수형 코딩\ntags:\n  - 독서\n---\n\n도서 링크: https://www.yes24.com/Product/Goods/108748841\n\n![쏙쏙 들어오는 함수형 코딩](https://image.yes24.com/goods/108748841/XL)\n\n## 3장 액션과 계산, 데이터의 차이를 알기\n\n### 액션, 계산, 데이터\n\n액션: 부수효과가 있는 함수, 실행 시점과 횟수에 의존  \n계산: 순수 함수  \n데이터: 이벤트에 대한 사실\n\n### 일상 생활에 액션, 계산, 데이터 적용하기\n\n자칫 잘못 계산시 모든 것이 액션 처럼 취급될 수 있음. 하지만 세분화해서 하나하나의 액션을 확인해보면, 내부에는 데이터와 계산이 존재\n\n### 계산 단계가 잘 인지되지 않는 이유\n\n계산 과정이 우리 사고 과정 중에 존재하기 때문에 드러나지 않는다.  \n결정, 판단이 들어가는 경우에는 대부분 계산이 필요하다.\n\n### 액션은 코드 전체로 퍼져나간다.\n\n액션을 호출하는 함수도 결국에는 액션이 된다.\n\n### 액션의 형태\n\n- 함수 호출\n- 메서드 호출\n- 생성자\n- 표현식\n- 상태\n\n## 4장 액션에서 계산 빼내기\n\n### 함수형 프로그래밍과 잘 맞는 제안\n\n- DOM 업데아트와 비즈니스 규칙 분리하기\n- 전역 변수 없애기\n- 어떤 실행 환경에서도 돌아가는 코드 작성 하기\n- 함수가 결괏값을 리턴하기\n\n## 5장 더 좋은 액션 만들기\n\n### 비즈니스 요구 사항과 설계를 맞추기\n\n- 현재 요구 사항은 장바구니에 담긴 제품을 주문할때 무료 배송인지 확인하는 것\n- 현재 코드는 장바구니가 아닌 제품의 합계 + 가격 을 해서 확인하고 있음\n- 따라서 calc_total 이라는 함수를 통해, 장바구니의 합계 금액을 알아내는 함수의 중복을 제거할 수 있음\n\n### 코드의 라인 수와 좋은 코드의 관계\n\n- 코드의 라인 수가 좋은 코드의 지표일 수 있음\n- 하지만 좋은 코드를 측정하는 지표는 라인 수 외에도 많음\n- 작은 함수는 이해하기 쉽고, 재사용에 용이함\n\n### 배열의 복사 비용\n\n- 배열 복사는 배열의 변경보다 비용이 많이 드는 것은 사실\n- 하지만, GC 를 통한 메모리 최적화 처리가 됨\n- 복사본을 사용할 때의 많은 장점이 있음\n    - 책 후반부 6장, 7장에서 다룰 예정...?\n\n### 원칙: 암묵적 입력과 출력은 적수록 좋다\n\n- 인자가 아닌 모든 입력은 암묵적 입력\n- 리턴값이 아닌 모든 출력은 암묵적 출력\n- 계산으로 만들기 위해 암묵적 입출력을 없애는 것을 액션에도 적용 가능\n- 액션을 계산으로 변경하지 못하더라도 암묵적 입출력을 줄이면 테스트가 용이해짐\n\n### 원칙: 설계는 엉켜있는 코드를 푸는 것이다\n\n분리되어 있는 것을 조립하는 것은 쉽다. 오히려 잘 분리하는 방법을 찾기 어렵다.\n\n- 재사용하기 쉽다.\n- 유지보수하기 쉽다.\n- 테스트하기 쉽다.\n\n### add_item 함수 더 좋은 설계 적용 시키기\n\n기존 코드에서는 add_item 함수는 cart, item 구조를 모두 알고 있었음.  \nitem 을 만들어 주는 함수를 별도로 분리하면, add_item 함수의 역할은 배열의 마지막에 신규 값을 추가해주는 역할만 하게 됨.  \n즉 유틸리티 함수가 됨.  \n**카피온 라이트**: 배열을 복사 후, 복사본을 조작해서 리턴하는 것\n\n## 6장 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기\n\n### 카피 온 라이트 원칙 세단계\n\n1. 복사본 만들기\n2. 복사본 변경하기\n3. 복사본 리턴하기\n\n### 카피 온 라이트로 쓰기를 읽기로 바꾸기\n\n- 읽기\n    - 데이터에서 정보를 가져온다\n    - 데이터를 바꾸지 않는다\n- 쓰기\n    - 데이터를 바꾼다.\n\n카피온 라이트는 쓰기를 읽기로 바꾼다.\n\n### 데이터의 불변성에 따른 계산과 액션 분리\n\n- 변경 가능한 데이터를 읽는 것은 액션\n- 쓰기는 데이터를 변경 가능한 구조로 만듬\n- 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터\n- 불변 데이터 구조를 읽는 것은 계싼\n- 쓰기를 읽기로 바꾸면 코드에 계산이 많아짐\n\n### 시간에 따라 변하는 상태가 있다.\n\n모든 어플리케이션은 결국 변경 가능한 데이터가 필요로 한다.\n\n### 불변 데이터 구조는 충분히 빠르다.\n\n- 불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화를 한다.\n- 가비지 콜렉터는 매우 빠르다.\n- 생각보다 많이 복사하지 않는다.\n    - 배열을 복사하게 되면 참조만 복사하게 된다. (얕은 복사)\n    - 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다.\n- 함수형 프로그래밍 언어에는 빠른 구현체가 있다.\n    - 특정 언어들은 불변 데이터 구조를 자체적으로 지원\n\n### 객체에 대한 카피 온 라이트\n\n- `Object.assign` 이라는 함수를 통해서 객체를 복사 가능함\n\n### 얕은 복사와 구조적 공유\n\n- 중첩데이터: 데이터 구조 안에 데이터 구조가 있는 것을 말함\n- 얕은 복사: 중첩 데이터에서 최상위 데이터 구조만 복사\n- 구조적 공유: 두 중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조하는 것\n\n중첩된 데이터에서 얕은 복사를 했기떄문에 구조적 공유가 되었다.\n\n## 7장 신뢰할 수 없는 코드를 쓰면서 불변성 지키기\n\n### 방어적 복사 규칙\n\n1. 데이터가 안전한 코드에서 나갈 때 복사하기\n2. 안전한 코드로 데이터가 들어올 때 복사하기\n\n### 방어적 복사를 사용하는 케이스\n\n- 언제 사용\n    - 신뢰할 수 없는 코드와 데이터를 주고 받아야할 떄 방어적 복사를 사용한다.\n- 어디서 사용\n    - 안전지대의 경계에서 데이터를 오고 갈 때 방어적 복사를 사용\n- 복사 방식\n    - 깊은 복사를 사용\n- 규칙\n    - 안전지대로 들어오는 데이터에 깊은 복사를 만듬\n    - 안전지대에서 나가는 데이터에 깊은 복사를 만듬\n\n## 8장 계층형 설계\n\n### 소프트웨어 설계란?\n\n코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것\n\n### 계층형 설계란?\n\n소프트웨어를 계층으로 구성하는 기술  \n비즈니스 규칙 - 장바구니를 위한 동작들 - 카피 온 라이트 - 언어에서 지원하는 배열 관련 기능\n\n## 12장. 함수형 반복\n\n### 기존 반복문 로직 forEach 로 변경\n\n```js\nfunction emailsForCustomers(customers, goods, bests) {\n  var emails = [];\n  for (var i = 0; i < customers.length; i++) {\n    var customer = customers[i];\n    var email = emailForCustomer(customer, goods, bests);\n    emails.push(email);\n  }\n  return emails;\n}\n\nfunction emailsForCustomers(customers, goods, bests) {\n  var emails = [];\n  forEach(customers, function (customer) {\n    var email = emailForCustomer(customer, goods, bests);\n    emails.push(email);\n  });\n  return emails;\n}\n```\n\n### map 함수 도출하기\n\n```js\nfunction emailsForCustomers(customers, goods, bests) {\n  var emails = [];\n  for (var i = 0; i < customers.length; i++) {\n    var customer = customers[i];\n    var email = emailForCustomer(customer, goods, bests);\n    emails.push(email);\n  }\n  return emails;\n}\n\nfunction biggestPurchasePerCustomer(customers) {\n  var purchases = [];\n  for (var i = 0; i < customers.length; i++) {\n    var customer = customers[i];\n    var purchase = biggestPurchase(customer);\n    purchases.push(purchase);\n  }\n  return purchases;\n}\n\n// map 함수 도출\n\nfunction emailsForCustomers(customers, goods, bests) {\n  return map(customers, function (customer) {\n    return emailForCustomer(customer, goods, bests);\n  });\n}\n\nfunction map(array, f) {\n  var newArray = [];\n  forEach(array, function (element) {\n    newArray.push(f(element));\n  });\n  return newArray;\n}\n```\n\n### 함수형 도구: map()\n\n```js\nfunction map(array, f) {\n  var newArray = [];\n  forEach(array, function (element) {\n    newArray.push(f(element));\n  });\n  return newArray;\n}\n```\n\n- 배열과 함수를 인자로 받아서\n- 빈배열을 만든 후\n- 원래 배열 항목으로 새로운 항목을 만들기 위해 f() 함수를 호출한 후,\n- 원래 배열 항목에 해당하는 새로운 항목을 추가\n- 새로운 배열을 리턴\n\n### 함수를 전달하는 세가지 방법\n\n- 전역으로 정의하기\n- 지역적으로 정의하기\n- 인라인으로 정의하기\n\n### filter 함수 도출하기\n\n```js\nfunction selectBestCustomers(customers) {\n  var newArray = [];\n  forEach(customers, function (customer) {\n    if (customer.purchases.length >= 3)\n      newArray.push(customer);\n  });\n  return newArray;\n}\n\nfunction selectCustomersAfter(customers, date) {\n  var newArray = [];\n  forEach(customers, function (customer) {\n    if (customer.signupDate > date)\n      newArray.push(customer);\n  });\n  return newArray;\n}\n\n// filter 함수 도출\n\nfunction selectBestCustomers(customers) {\n  return filter(customers, function (customer) {\n    return customer.purchases.length >= 3;\n  });\n}\n\nfunction filter(array, f) {\n  var newArray = [];\n  forEach(array, function (element) {\n    if (f(element))\n      newArray.push(element);\n  });\n  return newArray;\n}\n```\n\n### 함수형 도구: filter()\n\n```js\nfunction filter(array, f) {\n  var newArray = [];\n  forEach(array, function (element) {\n    if (f(element))\n      newArray.push(element);\n  });\n  return newArray;\n}\n```\n\n- 배열과 함수를 인자로 받아서\n- 빈배열을 만든 후\n- f() 함수를 호출한 후, 결과 배열에 넣을지 확인\n- 조건에 맞으면 원래 항목을 결과 배열에 추가\n- 결과 배열을 리턴\n\n### reduce 함수 도출하기\n\n```js\nfunction countAllPurchases(customers) {\n  var total = 0;\n  forEach(customers, function (customer) {\n    total = total + customer.purchases.length;\n  });\n  return total;\n}\n\nfunction concatenateArrays(arrays) {\n  var result = [];\n  forEach(arrays, function (array) {\n    result = result.concat(array);\n  });\n  return result;\n}\n\n// reduce 함수 도출\n\nfunction countAllPurchases(customers) {\n  return reduce(customers, 0, function (total, customer) {\n    return total + customer.purchase.length;\n  });\n}\n\nfunction reduce(array, init, f) {\n  var accum = init;\n  forEach(array, function (element) {\n    accum = f(accum, element);\n  });\n  return accum;\n}\n```\n\n### 함수형 도구: reduce()\n\n```js\nfunction reduce(array, init, f) {\n  var accum = init;\n  forEach(array, function (element) {\n    accum = f(accum, element);\n  });\n  return accum;\n}\n```\n\n- 배열, 초기값, 함수를 인자로 받아서\n- 초기값을 누적값으로 설정한 후\n- 누적 값을 계산하기 위해, 현재 값과 배열의 항목으로 f() 함수를 호출\n- 누적된 값을 리턴\n\n### 예제: 문자열 합치기\n\n```js\nreduce(strings, \"\", function (accum, string) {\n  return accum + string;\n});\n```\n\n### 연습 문제: min, max\n\n```js\nfunction min(numbers) {\n  return reduce(numbers, Number.MAX_VALUE, function (m, n) {\n    if (m < n) return m;\n    else return n;\n  });\n}\n\nfunction max(numbers) {\n  return reduce(numbers, Number.MIN_VALUE, function (m, n) {\n    if (m > n) return m;\n    else return n;\n  });\n}\n```\n\n### 연습 문제: 상황에 따른 map, filter, reduce\n\nmap 함수에 빈배열을 넘기면?  \n-> []\n\nfilter 함수에 빈배열을 넘기면?  \n-> []\n\nreduce 함수에 빈배열을 넘기면?  \n-> 초기값\n\nmap() 함수에 인자를 그대로 리턴하는 함수를 넘기면?  \n-> 얕은 복사가 된 array\n\nfilter() 함수에 항상 true를 리턴하는 함수를 넘기면?  \n-> 얕은 복사가 된 array\n\nfilter() 함수에 항상 false를 리턴하는 함수를 넘기면?  \n-> []\n\n### Iteration protocols (이터레이션 프로토콜)\n\n**이터러블 프로토콜**  \n이터러블: Symbol.iterator 메소드를 구현하거나 프로토타입 체인에 의해 상속한 객체   \nSymbol.iterator 메소드는 이터레이터를 반환\n\n**이터레이터 프로토콜**  \n이터레이터: next 메소드를 소유하며 next 메소드를 호출하면 이터러블을 순회하며 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 객체\n\n```js\nconst array = [1, 2, 3];\n\nconst iterator = array[Symbol.iterator]();\n\nconsole.log('next' in iterator); // true\n\nconsole.log(iterator.next()); // {value: 1, done: false}\nconsole.log(iterator.next()); // {value: 2, done: false}\nconsole.log(iterator.next()); // {value: 3, done: false}\nconsole.log(iterator.next()); // {value: undefined, done: true}\n```\n\n### 이터레이션을 이용한 reduce 구현\n\n```js\nconst reduce = (f, acc, iter) => {\n  if (!iter) {\n    iter = acc[Symbol.iterator]()\n    acc = iter.next().value\n  }\n  for (const a of iter) {\n    acc = f(acc, a)\n  }\n  return acc\n}\n```\n\n\n\n\n\n\n\n\n"},{"fields":{"slug":"/book/개발자원칙/","title":"개발자 원칙"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 개발자 원칙\ntags:\n  - 독서\n---\n\n도서 링크: https://www.yes24.com/Product/Goods/115852769\n\n![개발자 원칙](https://image.yes24.com/goods/115852769/L)\n\n## 01. 덕업일치를 넘어서 (박성철)\n\n개인의 동기를 이해하고 동기에 맞게 일을 주어야한다.  \n개발자는 단순 노동을 제공하는 사람이 아닌, 생산에 있어 큰 영향을 끼칠 수 있음  \n성과를 내는 주체로서 이를 위해 노력해야하고 목표에 집중할 수 있어야 함  \n팀워크가 좋은 팀은 의미있는 성과를 지속적으로 내며 늘 더 높은 목표에 도전, 공동의 목표를 위해 협력할 줄 알고, 서로 배우고 가르치며, 개인과 팀 모두 성장합니다.\n\n> 담쟁이 \n> \n> (도종환)\n> \n> 저것은 벽  \n> 어쩔 수 없는 벽이라고 우리가 느낄 때  \n> 그때,  \n> 담쟁이는 말없이 그 벽을 오른다   \n> \n> 물 한 방울 없고,  \n> 씨앗 한 톨 살아남을 수 없는  \n> 저것은 절망의 벽이라고 말할 때  \n> 담쟁이는  \n> 서두르지 않고 앞으로 나아간다  \n>\n> 한 뼘이라도 꼭 여럿이 함께  \n> 손을 잡고 올라간다  \n> 푸르게 절망을 다 덮을 때까지  \n> 바로 그 절망을 놓지 않는다  \n> \n> 저것은 넘을 수 없는 벽이라고  \n> 고개를 떨구고 있을 때  \n> 담쟁이 잎 하나는  \n> 담쟁이 잎 수 천 개를 이끌고  \n> 결국 그 벽을 넘는다\n\n## 오류를 만날 때가 가장 성장하기 좋을 때다.\n\n오류가 발생하면 소스 코드 레벨에서 이해하자.  \n구글링을 통해 해결되는 문제가 많을텐데, 소스 레벨에서 문제를 해결해야한다고 말하는 이유는 \n\n\n"},{"fields":{"slug":"/book/오브젝트/","title":"오브젝트"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오브젝트\ntags:\n  - 독서\n---\n\n도서 링크: https://www.yes24.com/Product/Goods/74219491\n\n![오브젝트](https://image.yes24.com/goods/74219491/L)\n\n\n## 설계 품질과 트레이드 오프\n\n결국 책임이 객체지향 애플리케이션 전체의 품질을 결정하는 것  \n\n객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.  \n\n### 데이터 중심의 영화 예매 시스템\n\n객체의 상태는 구현에 속한다. 구현은 불안정하기 떄문에 변하기 쉽다.  \n결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 된다.  \n데이터 초점을 맞춘 설계는 변경에 취약할 수밖에 없다.\n\n객체의 종류를 저장하는 인스턴스 변수와 인스턴스의 종류에 따라 베타적으로 사용될 인스턴스 변수를 하나의 클래스 안에 함꼐 포함시키는 방식은 데이터 중심의 설계안에서 흔히 볼수 있는 패턴\n\n### 설계 트레이드 오프\n\n**캡슐화**  \n상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다.  \n여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.  \n객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다.  \n\n| 구현             | 인터페이스         |\n| -------------- | ------------- |\n| 변경될 가능성이 높은 부분 | 상대적으로 안정적인 부분 |\n\n변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것까지는\n\n설계가 필요한 이유 -> 요구사항이 변경되기 때문  \n캡슐화가 중요한 이유는 -> 불안정한 부분과 안정적인 부분을 분리해서변경의 영향을 통제할 수 있기 때문\n\n**응집도와 결합도**  \n\n|          | 응집도                               | 결합도                                   |\n| -------- | --------------------------------- | ------------------------------------- |\n| 의미       | 모듈에 포함된 내부 요소들이 연관돼 있는 정도         | 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도  |\n| 객체 지향 관점 | 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지   | 객체 또는 클래스가 협력에 적절한 수준의 관계만을 유지하고 있는지  |\n| 변경의 관점   | **변경이 발생할 떄 모듈 내부에서 발생하는 변경의 정도** | **한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도** |\n\n일반적으로 좋은 설계란?\n높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계 === 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계\n\n### 데이터 중심의 영화 예매 시스템의 문제점\n\n데이터 중심의 설계는 캡슐화를 위반하고 객체의 내부 구현을 인터페이스의 일부로 만듬.  \n책임 중심의 설계는 객체의 내부 구현을 안정적인 인터페이스 뒤로 캡슐화가\n\n접근자와 수정자 (getter, setter) 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.  \n인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다.\n\n구현을 캡슐화할 수 있는 적절한 책임은 협력이라는 문맥을 고혀할떄만 얻을 수 있음 \n객체가 사용될 문맥을 추측할 수 밖에 없는 경우 -> 해당 객체가 어떤 상황에서는 사용될 수 있게 최대한 많은 접근자 메서드를 추가하게 되는 것  \n\n> 접근자와 수정 자에 과도하게 의존하느 설계 방식을 **추측에 의한 설계 전략**\n\n| 단일 책임 원칙                      |\n| ----------------------------- |\n| 클래스는 단 한가지의 변경의 이유만 가져야 한다는 것 |\n\n### 자율적인 객체를 향해\n\n스스로 자신의 데이터를 책임지는 객체  \n우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해 \n\n**캡슐화의 진정한 의미**  \n단순히 객체 내부의 데이터를 외부로부터 감추는 것 이상의 의미\n변경될 수 있는 어떤 것이라도 감추는 것을 의미한다.\n\n### 데이터 중심 설계의 문제점\n\n- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.\n- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.  \n\n객체의 행동보다 상태에 초점을 맞춘다. 데이터 중심의 관점에서 객체는 그저 단순한 데이터의 집합체이다.\n\n데이터를 처리하는 작업과 데이터를 같은 객체안에 두더라도 데이터에 초점이 맞춰져 있다면 만족스러운 캡슐화를 얻기 힘들다.  \n데이터를 먼저 결정하고 데이터를 처리하는 데 필요란 오퍼레이션을 나중에 결정하는 방식은 데이터에 관련 지식이 객체의 인터페이스에 고스란히 드러나게 된다.  \n"},{"fields":{"slug":"/book/프레임워크 없는 프론트엔드 개발/","title":"프레임워크 없는 프론트엔드 개발"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 프레임워크 없는 프론트엔드 개발\ntags:\n  - 독서\n---\n\n도서 링크: https://www.yes24.com/Product/Goods/96639825\n\n![프레임워크 없는 프론트엔드 개발](https://image.yes24.com/goods/96639825/XL)\n\n## 3장. DOM 이벤트 관리\n\n### YAGNI  원칙\n\nYou aren’t gonna need it.\n\n정말 필요하다고 간주할 때까지 기능을 추가하지 마라\n\n### DOM 이벤트 관련 사전 지식\n\n이벤트란?\n\n웹 어플리케이션에서 발생하는 동작으로 다양한 이벤트 타입이 존재한다.\n\n**속성에 핸들러 연결**\n\n`on`  속성을 통해  DOM  요소에 이벤트를 연결할 수 있음\n\n```jsx\nconst button = document.querySelector(\"button\");\nbutton.onclick = () => {\n\tconsole.log(\"click!\")\n}\n```\n\n한번에 하나의 핸들러만 연결할 수 있어서, 손실되기 쉽다는 단점이 있다.\n\n**addEventListener 로 핸들러 연결**\n\naddEventListener 를 통해서 DOM 노드에 이벤트를 추가할 수 있다.\n\n첫 번째 매개변수는 이벤트 타입, 두 번째 매개변수는 콜백 함수로 이벤트가 트리거될 때 호출된다.\n\n복수의 핸들러를 연결할 수 있다.\n\n`removeEventListener` 를 통해 핸들러를 제거할 수 있다. 이때 callback 함수의 참조를 유지해야한다.\n\n**이벤트 객체**\n\n웹 어플리케이션에 전달된 모든 이벤트에는 Event 인터페이스를 구현한다.\n\n이벤트의 종류에 따라 확장된 이벤트 사용할 수 있다.\n\n**DOM 이벤트 라이프 사이클**\n\n`addEventListener`  의 세 번째 매개변수는 useCapture로 기본 값은 false\n\n이벤트 버블링: 이벤트 target 노드에서 부터 시작해 모든 조상요소로 이벤트가 전파\n\n이벤트 캡쳐링: 조상요소에서 부터 시작해 이벤트 target 노드까지 이벤트가 전파\n\n`stopPropagation` 을 통해 버블 체인을 중단할 수 있다.\n\n캡쳐 단계: 이벤트가 html에서 목표 요소로 이동\n\n목표 단계: 목표 요소 도달\n\n버블 단계: 목표 요소에서 html 로 이동\n\n**사용자 정의 이벤트**\n\n`CustomEvent`  생성자 함수를 통해서 사용자 정의 이벤트를 생성할 수 있다.\n\n`dispatchEvent`  를 통해서 이벤트를 발생시키고, `addEventListener` 로 표준 이벤트 리스너를 추가할 수있다.\n\n### TodoMVC 에 이벤트 추가\n\n문자열에는 이벤트 핸들러를 추가할 수 없기 때문에 `document.createElement` API를 사용해 새 DOM 노드를 생성할 수 있다.\n\ntemplate 태그: 렌더링 엔진의 스탬프로 사용할 수 있는 보이지 않는 태그\n\n**기본 이벤트 처리 아키텍쳐**\n\n초기 상태를 기반으로 렌더링 → 이벤트 발생 → 새로운 상태 생성 → 새로운 상태 기반으로 리렌더링\n\n각각의 구성 요소에 events 를 바인딩.\n\n### 이벤트 위임\n\n리스트의 경우 매번 모든 리스트 요소에 이벤트를 핸들링하는 것보다, 부모 요소에 이벤트를 핸들링해 하위요소에서 이벤트가 울렸는지 확인하는 것이 성능상 좋다.\n"},{"fields":{"slug":"/ide/intellij/","title":"IntelliJ IDEA"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: IntelliJ IDEA\ntags:\n  - IDE \n---\n\n## 플러그인\n\n### 코드 리뷰 플러그인\nhttps://plugins.jetbrains.com/plugin/12206-new-relic-codestream-github-gitlab-prs-and-code-review  \nIDE 에서 바로 코드 리뷰를 달 수 있고, PR 생성도 가능하다.\n\n그리고 나한테 온 PR 요청도 알림으로 떠서 바로 확인할 수 있다.\n\n\n### 시간 추적 앱\nJira 에 시간 추적 기능을 사용하면서, 내가 해당 티켓에 소요된 시간을 주기적으로 적어야 했다.\n기존에는 포모도로를 진행하면서, 30분간격으로 나의 시간을 기입했다. \n물론 이 방법도 괜찮았지만 일주일의 일하는 패턴에서 중간 인터럽트를 확인하기 어려웠다. (30분 단위로 업무를 진행했다고 표현되기 때문에)\n\n![일주일 타임 시트](../attachments/intellij-2022-04-24-02-13-06.png)\n\n따라서 내가 해당 티켓에 소요된 시간을 정확하게 측정할 수 있는 도구가 필요했다.\n\nhttps://plugins.jetbrains.com/plugin/9286-darkyen-s-time-tracker\n\n해당 플러그인은 실제로 내가 코드를 작성한 타입핑 기준으로 시간을 측정해준다. 따라서 해당 티켓을 처리하는데 소요된 시간을 좀 더 정확하게 기입할 수 있다.\n\n하지만 브랜치마다 적용되는 건 아니여서 현재, 업무에 컨텍스트 스위칭이 발생했거나, 하루가 넘어가는 시점에서는 한번씩 reset time 을 입력해준다.\n\n\n### Jira Integration\n\nhttps://plugins.jetbrains.com/plugin/11169-jira-integration  \n다양한 필터 기능과 이슈 상세를 IDE 에서 확인할 수 있다.\n\n\n## 기타\n\n### jira 연결\n정리가 잘되어 있는 향로님 블로그\nhttps://jojoldu.tistory.com/260\n\n"},{"fields":{"slug":"/ide/vscode/","title":"Visual Studio Code"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Visual Studio Code\ntags:\n  - IDE\n---\n\n## User Snippet 추가 방법\n\n마크다운에서 작업을 진행하다가, 스니펫을 추가해야했다.\n\n**Code > Preferences > User snippet**\n\n![User snippet](../attachments/vscode-2022-04-10-21-34-51.png)\n\n적당히 자신이 사용할 파일의 확장자 별로 추가를 해도 되고, IDE 전역으로 사용할 수 있게 해도 된다.\n\n데일리 회고로 작성할 3fs 를 추가할 예정이여서 다음과 같이 작성했다.\n```json\n{\n  \"3fs\": {\n    \"scope\": [\"markdown\"], // 전역을 사용하게 셋팅했다면, 해당 snippet을 사용할 형식 지정\n    \"prefix\": \"fff\", // snippet \n    \"body\": [ // 실제 입력 되는 텍스트\n      \"## $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\\n\",\n      \"### Facts\\n\\n\",\n      \"### Feeling\\n\\n\",\n      \"### Finding\\n\\n\",\n    ],\n    \"description\": \"Facts, Feeling, Finding\" // 설명\n  },\n}\n```\n\nCURRENT_YEAR 같은 에디터에서 제공하는 상수도 사용 가능\nhttps://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables\n\n```markdown\n## 2022-04-10\n\n### Facts\n\n\n### Feeling\n\n\n### Finding\n```\n👍\n\n\n## markdown 파일에서 code suggestion 활성화\n\n마크다운 작성 시 code suggestion 이 안나올 때 아래 설정을 setting.json 에 추가한다.\n```json\n{\n  \"[markdown]\": {\n      \"editor.quickSuggestions\": {\n          \"other\": true,\n          \"comments\": false,\n          \"strings\": false\n      }\n  },\n}\n```\n\n\n"},{"fields":{"slug":"/memo/2022/","title":"2022년 기록"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 2022년 기록\ntags:\n  - 일기\n  - 회고\n  - 생각정리\n---\n\n## 2022-04-09  \n\n### Facts\n미루고 미루던 위키 블로그 드디어 시작\n\n### Feeling\n블로그를 열심히 해야 겠다는 생각에 조금 설렌다.\n\n### Finding\n아자아자 화이팅\n\n## 2022-04-10\n\n### Facts\n- 주말 회사 출근\n  - 12~6시 반까지 풀집중\n  - 침튜브 라디오\n- 릴레이 코로나 감염\n  - 집 내부에서 코로나가 유행하고 있다.\n- 포모도로\n  - 주말 2일 연속 8포모 이상 진행\n- vscode 관련 wiki 수정\n\n### Feeling\n- 주말 회사 출근\n  - 집중이 잘 된다.\n  - 오전에 집에서는 집중이 안되고, 카페는 마스크를 쓰고 있어서 답답해서, 보통 아무도 없는 회사로 출근함\n  - 우연히 평소에 굉장히 만나뵈고 싶었던 분도 만나게 되었음\n  - 일할때 침튜브를 소리만 틀어봤는데, 오히려 집중이 잘되고 시간이 가는줄 모름...\n- 릴레이 코로나 감염\n  - 갑자기 소년 가장이 되어서, 당황스러움...\n- 포모도로\n  - 학습할게 정말 많아서, 24시간이 모자르다.\n\n\n### Finding\n- 시간을 좀 더 효율적으로 사용할 수 있는 방법을 찾기\n  - 유튜브 삭제...? 넷플릭스 삭제...?\n- 주말에 집중잘되는 카페 찾기\n  - 조금 시간이 걸리더라도 여러 카페를 가보는 것도 좋을 것 같음\n\n## 2022-04-11\n\n### Facts\n- 스프린트 회고 진행\n  - 스프린트 목표를 작게 설정\n  - 필수 목표와, 선택 목표를 나누어 설정\n- 업무 병목\n  - 사용 기술에 대한 미숙으로 인한 업무 병목 발생\n- 포모도로\n  - 6포모 진행\n  - 하나의 기능을 구현하는데 많은 시간을 소요중\n\n### Feeling\n- 지난 스프린트에서 내가 해결하지 못한 티켓으로 인해 팀내 진행도가 저평가받았다.\n  - 우선순위가 낮다고 스스로 판단했던 티켓들로 인해 전체 진척도가 떨어지는 현상에 대해 죄송했다.\n  - 나로 인해 이번 스프린트의 목표가 작게 설정되는 것에 죄송했다.\n- 업무 병목\n  - 외부 라이브러리를 사용할 수 밖에 없는 상황에서, 문서가 거의 없거나, 제공하는 기능이 부실할 때 다시 작성해야하나, 아님 어떻게든 사용해야하나 고민이 된다.\n  - 결국 정해진 시간 동안 목적지로 가는 게임인데, 중간중간 생기는 선택지에 있어서 어떤 길이 더 빠른길인지 감이 오지 않는다.\n  \n### Finding\n- 너무 개발자 기준으로만 선택해서 업무의 우선순위를 나누지 않는다.\n- 앞으로 가야된다고 말하기 위해서는, 정말 내가 앞으로 갈 준비가 되어 있는 상태인지 확인하기\n  - 나의 말만 믿고 앞으로 달렸다가, 힘들다고 헥헥 거리면, 앞으로 가자는 말에 설득당해 진행했던 분의 상황이 난처해진다.\n  - 가능한 앞으로 갈 준비를 되도록 빨리한다.\n\n\n## 2022-04-12\n\n### Facts\n- 피드백으로 인한 이슈\n  - 피드백을 받는 상대를 고려하지 않음\n  - 사과를 드린 후, 정식적으로 피드백을 드림\n- 문제의 원인을 외부의 요인에서 부터 찾는 경향이 있음\n\n\n### Feeling\n- 피드백을 받은 상대 입장으로써 건강하지 않은 피드백을 드렸다는 점이 죄송스럽다.\n\n### Finding\n- 잘못된 점이나 아쉬운 점을 직접적으로 표현하기 보다, 더 좋은 방법 혹은 보충되었으면 하는 부분을 이야기한다.\n- 조심스럽고 겸손한 피드백을 작성해야한다.\n- 문제의 원인을 객관적으로 보는 훈련이 필요하다.\n\n\n## 2022-04-13\n\n### Facts\n- 회의 진행을 하면서 여러 생각이 드는 하루이다.\n\n### Feeling\n- 회의도 결국 여러 사람들과 진행하는 것이다 보니, 성향이 드러날 수 있다.\n  - 현실의 문제에 강박을 가지고 문제를 해결하는데 초점이 맞춰져 있는 사람\n  - 문제나 위기를 통해 성장의 기회를 얻고자 하는 사람 \n  - 불확실한 해결방법에 대해 도전하기 망설여지는 사람\n- 성향들이 모여 좀처럼 결론이 나지 않는 경우가 많았다.\n- 이러한 루틴을 깨기 위해서는 어떤 방식을 도입을 해야하지는 고민이 든다.\n- 매번 의견이 극단적으로 변한다.\n  - 변론: 고집을 피우고 싶지 않아서 좋은 의견에 대해서 빠르게 수용하는 것이다.\n  - 생각: 내가 원래 가지고 있던 의견이 이렇게 금방 포기할만큼 빈약한 것이 아닐까 생각해보기\n\n### Finding\n- 솔직히 회의 진행 방식을 어떻게 해야할지 감이 오지 않는다.\n  - 회의를 끝나면 항상 개인적으로 회고를 해봐야겠다.\n\n\n## 2022-04-15\n\n### Facts\n- 인프랩 입사 이래로 가장 성공적인 스프린트 회고\n  - 나는 지난 스프린트에 밀린 업무를 치느라 많은 티켓을 치지 못함\n  - 그로 인해 같은 파트원분들이 거의 이번 스프린트의 많은 부분을 담당해주심\n\n### Feeling\n- 성공적인 스프린트 회고가 주는 뿌듯함을 처음 느껴볼 수 있었다.\n  - 지난 스프린트때 밀린 업무가 있어서, 할 수 있을지 없을지 확신이 없었는데, 이번 프로젝트 구성원분들이 캐리해주셨다.\n  - 작업자로써 내가 맡아야하는 부분을 끝까지 책임지고 하고 싶었다.\n    - 하지만 시간적으로 불가능하다는 것을 알고 있었다.\n    - 업무를 해결하지 못하고 붙잡고 있는 것이 오히려 팀적으로 지속적으로 불안한 상태를 만든다.\n- 그동안 스프린트 회고를 하면 2시간은 기본으로 넘었었는데, 이번엔 40분 만에 끝났다.\n  - 스프린트가 성공적으로 끝나면 오히려 서로 할말이 없다는 것을 알게되었다.\n\n### Finding\n- 최대한 스프린트 목표는 미루지 않는다.\n- 성공의 맛을 잊지 말고, 다음 주도 꼭 이 맛을 느껴본다.\n\n\n## 2022-04-16\n\n### Facts\n- Clean Code 정독 시작\n\n\n### Feeling\n- 최근에 책을 많이 읽지 않아서, 공부 스타일에 변화도 줄 겸 Clean Code 책을 읽어 보려고 한다.\n\n\n### Finding\n- 다음주 내로 꼭 다 읽는다!\n\n\n## 2022-04-18\n\n### Facts\n- 일요일 기념 생각 정리\n- 전혀 예상치도 못한 사람에게 \"근데 어쩌다 개발자 하게 되었어요?\" 라는 질문을 받음 \n  \n### Feeling\n- [침착맨 휴방 공지](https://cafe.naver.com/zilioner/46279?art=ZXh0ZXJuYWwtc2VydmljZS1uYXZlci1zZWFyY2gtY2FmZS1wcg.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjYWZlVHlwZSI6IkNBRkVfVVJMIiwiY2FmZVVybCI6InppbGlvbmVyIiwiYXJ0aWNsZUlkIjo0NjI3OSwiaXNzdWVkQXQiOjE2NTAyOTYwNzkzNDV9.Ek0zBRl114wvADSL__kEseBJI5bfYSUt7yc6B65kHyk)\n  - **\"즐거우면서 버겁다\"** 라는 말이 지금 현재 나의 상태를 가장 잘 표현하는 말인것 같다.\n- 근데 어쩌다 개발자 하게 되었어요? 라는 질문에 쉽게 답하지 못했다.\n  - 자연스럽게 흘러가면서 살다보니, 개발자가 되어 있었다.\n  - 너무 빨리 일을 시작하다보니, 이른 나이에 사회가 원하는 가면을 쓰게 되었고, 가면을 쓰고 생활하는 시간이 길어지다보니, 가면을 벗었을 떄의 모습이 어땠는지 기억이 잘 나질 않는다.\n- 오랜만에 이런저런 이야기 많이 함\n  - 감사합니다 ㅎㅎ\n\n### Finding\n- 주말에 하루는 코딩말고, 다른 활동 해보기\n- 내가 이루고 싶은 게 뭔지 꼭 찾기\n- 주말 일요일에는 여유를 가지고 일주일 돌아보기\n\n## 2022-04-19\n\n### Facts\n- 스프린트 플래닝 진행\n  - 닭이 먼저냐, 달걀이 먼저냐\n- 최근들어 집중이 가장 잘 됨\n\n### Feeling\n- 스프린트 플래닝을 진행했다\n  - 개발 인원이 시간 측정을 하려면, 목표를 미리 정해야하고,\n  - 목표를 미리 정하려면, 개발 인원이 해당 목표를 이루는 대략적인 시간 공유가 되어야한다.\n  - 대략적인 목표 치를 정한 후, 모였을때 구체화하는 것을 제안드렸고, 다음주에는 그렇게 진행할 예정\n- 일요일에 한 생각정리가 도움이 되는지, 오늘 업무 집중이 최근들어 가장 잘되었다.\n  - 이 페이스만 유지하길...!\n\n\n### Finding\n- 아직 과도기기 때문에 개선할 부분이 있으면 바로바로 말한다.\n  - 숨기면 바보\n\n## 2022-04-20\n\n### Facts\n- 공동 작업자가 들리게 해서는 안되는 말을 해버렸다.\n  - 한숨을 쉬면서 \"진짜 힘들다\" 라는 말을 했다.\n  - 코드 리뷰가 끝난 직후였다.\n- 프론트엔드 테크 리뷰\n  - 코드 리뷰에 관한 이야기\n  - 레거시에 대한 이야기\n\n### Feeling\n- 너무 죄송하다.\n  - 코드 리뷰가 힘들다는게 아니라, 앞으로 해야할 일들이 머리속에 계속 정리가 되고 있지 않아서 힘든거였는데, 타이밍이 좋지 않았다.\n  - 팀원의 사기를 떨어뜨리는 말을 무의식중에 한 것에 대해 반성한다.\n- 코드 리뷰 정책\n  - 파편화 되어 있고, 문서화가 안되어 있는 부분을 다같이 이야기할 수 있었다. 은근 서로 모르는게 많더라\n  - 코드를 받는 사람이 코멘트를 적극적으로 달아\n\n\n### Finding\n- 생각하고 행동한다.\n- 비언어적인 표현에 조심하고 경계한다.\n\n\n## 2022-04-22\n\n### Facts\n- 스프린트 회고를 진행\n  - 예측 불가능한 업무에 대한 작업자의 심리적 안정감\n    - 현재 작업자의 역량을 판단하는 기준이 스토리의 완료율\n    - 현재 작업 특성상 예상하지 못한 작업으로 인해 스토리의 인수조건이 늘어날 수 있음\n    - 예측할 수 없는 작업으로 인해 스토리가 완수되지 못하는 것에 대한 작업자의 스트레스를 말씀드림 \n  - 프론트엔드 업무 방식의 변화 제안\n    - 기존에는 템플레이팅 -> API 연결 테스트\n    - API 연결 테스트 -> 템플레이팅\n- 나의 작업 역량에 대한 깊은 고민\n  - 4주에 걸쳐서 해결하지 못한 티켓이 존재.\n  - 고민 끝에 다음 주부터 다른 분이 해당 티켓을 맡아주시는 걸로 결론을 냈다.\n\n### Feeling\n- 인수조건 이야기 같은 경우에는 꼭 하고 싶은 이야기였어서 속이 후련했다.\n  - 이번 개발팀 내부에서도 새롭게 나오는 인수조건에 대해 많이 민감했다는 생각도 들었다.\n  - 일단 프로세스나 방식이 개선되었으므로 분명 다음 스프린트는 더 좋은 결론은 도출해낼 수 있을 것 같다는 생각이 든다.\n- 프론트엔드 업무 방식의 변화\n  - 이번 프로젝트를 하는 프론트엔드 구성원과 충분한 이야기를 하지 않은채로 공개적인 자리에서 논의를 한게 아닌가 싶다.\n  - 나의 생각: 문제점을 내부에서 논의하고 공개적인 자리에서 이야기하는 것은 작은 구성원 조직에서는 필요가 없는 작업이라고 생각한다. (현재 프로젝트 구성원 7명)\n  - 또 다른 생각: 공개적인 자리에서 문제점이라고 나온 이슈가 자신과 관련이 있는 이슈라면 조금은 당황할 수 있을 수 있다.\n  - 나 스스로의 결론: 스프린트 회고 전에 팀 내부에서 논의를 나누는 것까지는 오케이. 하지만 이야기를 할지 안할지는 내가 판단하고 싶다.\n- 4주동안 해결하지 못한 작업이 있다면, 어쩌면 나는 그 티켓을 처리할 수 있는 역량이 부족한것이 아닐까 라는 고민을 했다.\n  - 같은 구성원 입장에서 처리되지 않은 티켓으로 인해 내부의 리소스가 현재의 문제를 해결하는데 온전히 포커스되지 못하고, 새어나가는 것에 불만이 있을 수 있다고 생각했다.\n  - 나 스스로도 내가 만약 이 티켓에 1주 혹은 2주의 시간을 더 사용한다고 완벽하게 해결해낼 수 있을 거라는 확신이 들지 않았다.\n  - **내가 시도해보고 이 방법으로는 해결할 수 없겠다**라고 판단한 것들을 구성원이 믿지 않는다는 느낌을 받았다.\n  - 그래서 나는 이 티켓을 내 역량으로는 해결할 수 없는 일이라고 판단해 담당자 교체를 요청했다.\n  - 작업자의 고집만큼 위기를 측정하는데 방해되는 요인은 없는 것 같다.\n\n### Finding\n- 고집을 부리지 말자.\n- 냉정하게 상황을 바라보자.\n- 신뢰를 깨지 말자.\n\n\n## 2022-04-23\n\n### Facts\n- 밀린 블로그 글감 정리\n\n\n### Feeling\n- 묵혀두었던 블로그 글들을 정리했다.\n  - 위키 방식의 글정리는 나한테 너무 잘 맞는 것 같다.\n \n### Findin\n- 주말에 몰아서 적더라도 평일에 생각난 것은 틈틈히 기록해두기\n\n\n## 2022-04-24\n\n### Facts\n- 노 코딩데이\n  - 영화 보고, 미용실도 가고, 도서관도 가고, 카페도 갔다.\n\n### Feeling\n- 일주일에 한번쯤은 코딩없는 날로 정해보았다.\n  - 프로젝트를 진행중이여서 마음 한켠은 찜찜하기는 했다.\n  - 그래도 여유로웠다.\n  - 프로젝트 막바지에서는 할 수 있을지 잘 모르겠지만, 지금은 효과가 있는 것 같다.\n\n### Finding\n- 여유있는 삶을 추구하기\n\n## 2022-04-26\n\n### Facts\n- 프로젝트 팀원이랑 뜨겁게 논의\n  - 서로 학습에 대한 회의감이 듬\n  - 추후 개선 방안에 대해 이야기함\n\n\n### Feeling\n- 이번 기회에 진솔한 대화를 나눈것 같아서 다행이다. 어제 논의를 통해 찾은 문제점이다.\n  1. 긴가민가는 하는데 안 찾아보지 않는다.\n  2. 본인이 알고 있는 지식의 바운더리를 벗어나지 않는다.\n  3. 지금 당장 해결하고자 하는 문제를 해결하지 않고 다른 공부를 한다.\n  4. 지금 단계에서 확신이 없는 사람이 확신을 가진 사람을 따라야하는데, 마땅한 대응책없이 의견에 대한 반대를 한다.\n- 그래서 지금은 임시방편으로 작성하고, 추후 변경에 있어서는 서로 적극적인 태도를 임하기로 했다.\n- 4개월전에도 동일한 내용으로 논의를 했었는데, 지금도 똑같은 논의를 하고 있는 것은 잘못된 것 같다.\n- 더불어 이번 프로젝트가 끝났을 때 나 자신이 프로젝트 시작 전과 어떤 점이 달라졌는지 이야기 해볼 수 있는 기회를 만들자고 했다.\n  - 팀 문화면 베스트일 것 같다.\n\n### Finding\n- 꾸준히 내가 성장하고 있는지 확인한다.\n\n## 2022-04-29\n\n### Facts\n- 리프데이로 서핑을 배움\n- 인생 처음으로 드럼 레슨을 받음\n\n\n### Feeling\n- 서핑이 정말 재미있었다. 초반에는 균형 잡는게 너무 어려워서 엄청 넘어졌지만, 후반부에는 어느정도 탈 수 있게 되었다.\n- 서핑을 갔다와서 피곤했지만 저녁 9시에 드럼 레슨을 받음.\n  - 분명 잘할 줄 알았는데, 두팔 두다리가 마음대로 움직여지지 않음\n  - 선생님의 uptown funk 연주를 보니, 너무 멋졌다. 동기부여가 잘 되었다...!\n  - 내일 연습실을 개방해주신다고 하셔서 가서 마저 연습할 예정 \n\n### Finding\n- 새로운 체험을 많이 해봐야겠다.\n- 사진을 많이 찍어야겠다. 남는건 사진뿐인 것 같다.\n\n## 2022-04-30\n\n### Facts\n- 드럼 연습을 1시간 진행\n- 남은 하루 동안 회사일 진행\n\n### Feeling\n- 드럼 연습만 빼면 다른 토요일과 그렇게 다르지 않았다.\n- 하지만 드럼 연습 한시간 덕분에 뭔가 생기가 돌았다.\n\n### Finding\n- 기왕 하기로 한거 꾸준히 연습하기\n\n\n## 2022-05-03\n\n### Facts\n- 아침 운동\n- 프론트엔드 전문성에 관한 피드백\n- nextstep 코틀린 시작\n\n### Feeling\n- 조금 일찍 일어나서 아침에 운동을 했다.\n  - 오후에 너무 피곤했다.\n- 퍼포먼스가 안나는 원인이 파트차원에서 너무 적나라하게 드러나서 힘들었다.\n  - 매번 느끼는 거지만 항상 해결하기 힘들다.\n- 새로운 것을 학습하는 것은 언제나 설레면서, 두렵다.\n  - 정말 새로운 것인 만큼 알게된 것을 기록하면서 학습해야겠다고 다짐하였다.\n\n### Finding\n- 오전에 30분만 더 자보자.\n- 하나의 이야기라고 생각하고 이겨내보는 연습을 하자.\n- 새롭게 알게 된것들을 기록하자.\n\n\n## 2022-05-08\n\n### Facts\n- 회사분들과 실내 서핑\n- 몰리와 함께 TDD\n- 진행하는 프로젝트 구조 및 코드 설계 w. 몰리\n\n### Feeling\n- 취미가 너무 많이 생겨버려서 공부할 시간이 줄어들었다.\n  - 여가 생활을 가지면서 여유롭다라는 기분을 느낄수 있어서 좋았다. \n- 이펙티드 코틀린 step2 를 TDD 로 함께 진행하면서, 몰리가 정말 테스트에 진심이라는 것을 알게되었다.\n  - 단계를 쪼개가면서 코드를 작성하는 연습을 했다.\n- 무지함에서 나오는 고민을 줄여나가는 과정을 빠르게 해야겠다고 느꼈다.\n  - udemy 에 구매한 강의를 최대한 빨리 학습해야겠다는 다짐을 했다.\n  - 그래도 어느정도 합의점을 찾았다고 생각한다.\n\n### Finding\n- 여유로운 삶을 살자.\n- 시간을 잘 활용해서 내가 모르는 것들을 하나씩 줄여갈 수 있도록 노력한다.\n\n\n## 2022-05-13\n\n### Facts\n- 스프린트 회의\n  - 남은 스토리가 3개 정도 프로젝트가 정말 마무리가 되고 있다\n- 드럼 수업에서 \"너의 의미\" 연주\n\n## 2022-05-14\n\n### Facts\n- 할아버지, 할머니 구순\n\n## 2022-05-15\n\n### Facts\n- 인생 첫 요가\n- 이펙티브 코틀린 3단계 과제 수행\n\n\n## 2022-05-16\n\n### Facts\n- 5초 스피닝 룰 시작\n- 어텀한테 드럼 교본 받음\n- 디자인 시스템 전체 회의\n  - 회의에서 실수한 점이 있음\n  - 팀원의 허락을 구하지 않고, 팀을 폄하함\n\n## 2022-05-17\n\n### Facts\n- 마케팅 스크립트 정리\n\n## 2022-05-18\n\n### Facts\n- 점심 시간 3km 걷기\n- 코틀린 step3 리뷰 반영\n- 코틀린 step4 작업 시작\n\n\n## 2022-05-19\n\n### Facts\n- 이펙티브 코틀린 사내 스터디\n\n### Feeling\n- 모르는 걸 찾는 것보다, 뭘 모르는지 찾는게 더 어렵다.\n  - 모르는 것이 뭔지 아는 것이 정말 중요한 것 같다. \n\n## 2022-05-20\n\n### Facts\n- 대구 방문\n\n### Feeling\n- 팀원들과 다 같이 대구에 방문하였다.\n  - 지인분의 장례를 가본 경험이 많지 않아서, 감정이 복잡했다.\n  - 나한테도 이런 일이 일어난다면 나는 무너지지 않을 수 있을까? 라는 생각에 많이 힘들었다.\n  - 태연하게 인사를 나누고, 말씀을 나누는 모습 내부에는, 얼마나 많은 슬픔을 참고 있을지 가늠이 되지 않았다.\n\n\n## 2022-05-21\n\n### Facts\n- 코드스쿼드 2주차 마지막 리뷰 진행\n- 오브젝트 책 1장 독서\n\n## 2022-05-22\n\n### Facts\n- 아침 요가\n- 이펙티브 코틀린 미션 진행\n  - 문자열 덧셈 계산기\n\n## 2022-05-23\n\n### Facts\n- 오브젝트 책 스터디 시작\n- 강의실 프로젝트 회고\n\n### Feeling\n- 최근 코틀린 코드를 작업하면서, 프로그래밍을 잘못하고 있다는 생각이 너무 강하게 들었다.\n  - 어떠한 요구사항을 너무 절차적으로 풀어내는 것이 아닌가? 내가 작성한 코드를 누군가가 수정한다고 했을 때 변경의 유연한가?\n  - 이러한 고민은 객체지향 프로그래밍에 대한 공부가 시급하다는 신호탄이였고, 파트에서 오브젝트 책 스터디를 하게되었다.\n\n## 2022-05-24\n\n### Facts\n- 벨로버트님 회사 방문\n  - 영상 보안에 대한 하소연\n  - 싸인 받음\n![velopert 님 싸인](../attachments/2022-2022-05-27-01-45-14.png)\n- 향로의 프론트엔드 어셈블\n- 냉동삼겹살 w 몰리, 어텀\n\n\n### Feeling\n- DRM 문제를 함께 이야기 할 수 있는 분이 가까이 있는 것만으로도 행복했다.\n  - 라프텔은 샤카플레이어를 사용하고 있다고 한다.\n  - videojs 의 허접한 문서와 에러 처리로 너무 힘들었는데, 한줄기 희망처럼 다가왔다.\n- 향로한테 또 혼났다.\n  - 내가 관심있어 하는 분야와 팀적으로 필요한 능력이 다르다는 것을 아주 강하게 꼬집어주셨다.  \n  - 내가 하고 있기때문에 팀원들도 알아야되라는 생각이 틀렸다는것을 알면서도, 계속 실수한다.\n  \n### Finding\n- 강요라는 강점을 받지 않도록 주의하자.\n\n\n## 2022-05-25\n\n### Facts\n- 프론트엔드 관심사 맞추기\n  - 팀 게임을 하기위한 준비과정\n\n### Feeling\n- 팀원들의 관심사를 맞춰서 팀적으로 함께 할 수 있는 부분이 있는지 알아보았다.\n  - 아니나 다를까 거의 모두 달랐다.\n  - 최근 객체지향에 관심이 많아서 오브젝트 책 스터디를 시작했는데, 해당 스터디에 대한 생각이 다를 수도 있다는 것을 너무 늦게 깨달았다.\n\n## 2022-05-26\n\n### Facts\n- 동영상 이슈\n  - 샤카 플레이어 사용 예정\n- 디자인 시스템 사용 결정\n  - React - mantine\n  - Vanila - bootstrap\n\n### Feeling\n- 드디어 사용하는 디자인 시스템 라이브러리가 결정되었다.\n  - 중간중간 의견 충돌도 많았고, 지치는 포인트들도 있었지만, 모두다 현재 문제를 해결하고 싶다는 마음으로 모였다는 것을 알게된 기간들이었다.\n\n## 2022-06-14\n\n### Facts\n- 첫 요가원\n\n\n### Feeling\n- 집에서 유튜브나 줌을 통해서 받는 요가랑 차원이 다르다. 너무 힘들었다\n  - 일단 동작 자체가 빠르고, 고인물들이 많아서 그런가, 내가 제일 못했다.\n\n\n### Finding\n- 요가를 꾸준히 해서 땅집기를 반드시 성공한다\n\n## 2022-06-17\n\n### Facts\n- 심야 FE 발표\n  - 랠릿 어떻게 만들어졌을까?\n\n![첫 오프라인 발표 심야 FE](../attachments/2022-2022-06-21-00-42-40.jpg)\n\n\n### Feeling\n- 발표 너무 떨었다.\n  - 정말 많은 분들과 이야기했고, 인프런에서의 일하는 방식에 대해 많이 질문 주셨다.\n  - 많이 변했다는 것을 느꼈다. 전에는 우리 회사 이렇게 일한다고 말할 때 너무 부끄럽고, 말하기 껄끄러웠는데 지금은 더 이야기하고 싶어서 이것저것 꺼내게 된다.\n  - 나도 모르는 사이에 점점 나이스해지고 있는 것 같다.\n  - 말을 하다보니 점점 정리가 되고, 좋은 팀에서 일을 하고 있다는 생각이 들어서 행복한 하루였다.\n\n\n## 2022-06-18\n\n### Facts\n- 여름 방학 계획 세우기\n- m1 셋팅 가이드 추가된 사항 다시 읽기\n\n## 2022-06-19\n\n### Facts\n- 오브젝트 4장 읽기 w. 몰리\n- 전사 QA 전 기존 개발 QA 사항 마무리\n\n\n### Feeling\n- 확실히 혼자 읽을 때에 비해서는 속도가 나는 것 같다. (약 1시간 20분 소요)\n\n## 2022-06-20\n\n### Facts\n- 저녁 요가\n- 심야 FE 모각코 시작\n- 변경 가능한 컴포넌트에 대한 고민으로 해당 링크들 읽게됨\n  - [토스ㅣSLASH 22 - Effective Component 지속 가능한 성장과 컴포넌트](https://www.youtube.com/watch?v=fR8tsJ2r7Eg)\n  - [변경에 유연한 컴포넌트](https://jbee.io/web/components-should-be-flexible/)\n  - [Headless UI Library란?](https://jbee.io/react/headless-concept/)\n  - [좋은 코드란 무엇일까?](https://jbee.io/etc/what-is-good-code)\n  - [지역성의 원칙을 고려한 패키지 구조: 기능별로 나누기](https://ahnheejong.name/articles/package-structure-with-the-principal-of-locality-in-mind/)\n  - [AHA Programming 💡](https://kentcdodds.com/blog/aha-programming)\n  - [React Hooks: Compound Components](https://kentcdodds.com/blog/compound-components-with-react-hooks)\n- 오브젝트 4장 블로그 요약 정리\n\n### Feeling\n- 요가 최고!\n  - 어깨서기 76% 정도 성공함\n  - 브릿지로 버티기 가능함\n- 모각코 첫날\n  - 막상 공부하려니 어떤 걸 공부해야할지 감이잘 오지 않음\n  - 그래서 오늘 스터디한 책 내용을 정리함\n- 좋은 리액트 관련 칼럼\n  - 내가 작성한 코드의 대부분이 Bad Case\n  - 좋은 건 알겠는데 어떻게 리펙토링을 해야할지는 감이 오지 않는다.\n\n\n### Finding\n- 천천히 리팩토링 해보자\n  - 하다보면 감각이 생기겠지.\n\n## 2022-06-27\n\n### Facts\n- 파트별 워크샵 진행\n- 이력서 정리\n\n\n## 2022-09-28\n\n### Facts\n- 플레이어 디버깅 및 오류 수정\n- 임성현님 강연\n\n\n### Feeling\n- 진행하고 있는 업무가 많다. 하지만 마무리가 잘 되지 않는다.\n  - 마무리를 하는 시점에서 계속해서 새로운 일이 생기다보니, 마무리하는데 시간이 오래 걸린다.\n- 최근 워라벨에 관심이 생겼는데, 임성현님의 강연을 듣고 나서 조금은 정리가 되었다.\n  - 내가 가지고 있는 가치관을 근거로 행동을 하면 될것 같다.\n  - 가치관을 세우는 것이 어렵다.\n\n\n### Finding\n- 나는 어떤 것을 했을 때 가장 행복한지 찾기 (다음주 금요일 까지)\n\n\n## 2022-10-04\n\n### Facts\n- shaka-player PR 머지\n  - https://github.com/shaka-project/shaka-player/pull/4537\n\n### Feeling\n- 내가 오픈 소스를 기여했다는 사실 만으로 뿌듯하다.\n- 영상 영역 작업을 하면서, 내심 내가 하고 있는 일이 단순히 다른 사람이 만들어 놓은 라이브러리를 옵션을 변경하면서 사용하는 것이 전부가 아닌가, 걱정이 되었었는데, 이번 이슈를 해결하면서, 라이브러리 구성 코드의 흐름을 대충 알게되었다.\n- 라이브러리 기여를 하는데 Webstorm 디버거를 사용했다.\n  - 확실히 console.log 를 찍는 거보다 괜찮은 것 같다.\n  - 관련해서 사내 기술블로그도 작성 예정이다.\n\n### Finding\n- 업무에서도 내가 성장할 수 있는 포인트를 계속해서 찾아내고, 적용해야한다.\n\n\n\n\n"},{"fields":{"slug":"/memo/links/","title":"유용한 링크 모음"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 유용한 링크 모음\ntags:\n  - 링크\n---\n\n## Frontend\n\n- [x] [토스ㅣSLASH 22 - Effective Component 지속 가능한 성장과 컴포넌트](https://www.youtube.com/watch?v=fR8tsJ2r7Eg)\n    - Headless 기반의 추상화하기\n    - 한 가지 역할만 하기\n    - 도메인 분리하기\n- [x] [변경에 유연한 컴포넌트](https://jbee.io/web/components-should-be-flexible/)\n- [x] [Headless UI Library란?](https://jbee.io/react/headless-concept/)\n- [x] [좋은 코드란 무엇일까?](https://jbee.io/etc/what-is-good-code)\n- [x] [지역성의 원칙을 고려한 패키지 구조: 기능별로 나누기](https://ahnheejong.name/articles/package-structure-with-the-principal-of-locality-in-mind/)\n    - 특정 목적 달성은 높은 응집력을 갖는 특정 폴더 내에서, 관련 맥락을 머리 속 캐시에 적재한 상태로 이루어진다\n- [ ] [AHA Programming 💡](https://kentcdodds.com/blog/aha-programming)\n- [ ] [React Hooks: Compound Components](https://kentcdodds.com/blog/compound-components-with-react-hooks)\n- [ ] [Ref를 활용한 React Hooks 개선](https://kwoncheol.me/posts/improve-your-hooks-with-ref)\n- [x] [핀다에서 쓰는 React Custom Hooks](https://kwoncheol.me/posts/custom-hooks-of-finda/)\n    - 공통적으로 사용하는 값을 다루는 로직은 custom hook으로 만들기에 적합하지 않습니다\n    - 공통의 값을 사용하는 훅은 값의 변화가 일어났을때 변화가 어는 hook 에서 일어난건지 찾기 어렵다.\n- [x] [단단한 컴포넌트 부수기](https://kwoncheol.me/posts/break-the-component)\n    - 제어의 역전을 통한 컴포넌트의 상태를 숨길 수 있다.\n    - 그 중 Provider 를 통한 숨김이 인상 깊다.\n- [x] [Ref를 활용한 React Hooks 개선](https://kwoncheol.me/posts/improve-your-hooks-with-ref)\n  - ref 를 사용해 custom hook 의 callback 을 최적화할 수 있다.\n  - useEffect 내부에서 참조하는 함수를 같게하기 위한 방법중에 하나로 변경되지 않는 함수 안에서 ref 를 사용하는 것이 있다.\n- [ ] [React Testing Library를 이용한 선언적이고 확장 가능한 테스트](https://ui.toast.com/weekly-pick/ko_20210630)\n- [ ] [Select 컴포넌트](https://so-so.dev/react/make-select/)\n- [ ] [Scoped Context](https://so-so.dev/react/scoped-context/)\n- [ ] [개발자를 위한 친절한 UI 컴포넌트 라이브러리 만들기 - 2021 Korean version -](https://www.youtube.com/watch?v=xQOpjychnwQ&ab_channel=LINEDevelopers)\n  - https://engineering.linecorp.com/ko/blog/ui-component-library-for-developers-with-typescript-storybook\n- [ ] [합성 컴포넌트로 재사용성 극대화하기](https://fe-developers.kakaoent.com/2022/220731-composition-component/)\n\n## Test\n\n- [x] [뱅크샐러드 iOS팀이 숨쉬듯이 테스트코드 짜는 방식](https://blog.banksalad.com/tech/test-in-banksalad-ios-1/)\n  - 다시 읽어보기\n\n## PO\n \n\n"},{"fields":{"slug":"/memo/한 번만 읽어도 책 내용 다 기억하는 기적의 독서 메모 법/","title":"한 번만 읽어도 책 내용 다 기억하는 기적의 독서 메모 법"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 한 번만 읽어도 책 내용 다 기억하는 기적의 독서 메모 법\ntags:\n  - youtube\n  - 메모\n---\n\n## 영상 링크\n\n[![Watch the video](https://i.ytimg.com/vi/fxdPHw8vhog/sddefault.jpg)](https://www.youtube.com/embed/fxdPHw8vhog?si=AjrWOhHF91Up2DiM)\n\n## 내용 요약\n\n\n메모의 내가 무언가를 배울 때 효과적으로 흡수, 혹은 내가 가지고 있는 것을 끄집어내는 효과가 있다.  \n메모의 양이 많으면 오히려 **핵심적인 내용을 놓칠** 수 있다. 따라서 우리는 핵심 키워드를 뽑아내서 **가능한 한 적게 메모**하는 것이 좋다.  \n내용을 과감하게 버려라. 그렇게 되면 정말 중요한 내용만 남는다. 그리고 그 중요한 키워드를 남기기 위해 고민하는 과정 동안 머릿속에 남는다.  \n속기사처럼 혹은 책의 내용을 필사하는 식으로 메모하게 되면 책의 내용이 머릿속에 오래 남지 않는 이유는 여기에 있다.  \n**자기화**란 책에서 얻은 지식에 나의 내용을 덧대어 정리하는 것이다. 단순히 책의 내용을 베끼는 것이 아닌 해당 내용의 나만의 언어 및 생각으로 메모해 보자.  \n책을 읽다가 책을 보지 않고 지금까지 읽었던 단락이나, 장의 핵심을 머릿속으로 정리해 본다.(**순간의 생각**). 그 후 그 생각들이 5~6가지 정도 쌓이면 지금까지 정리했던 것의 맥락을 읽는 연습(**생각의 이음**)을 해보자.  \n메모를 습관화하고 싶다면 내가 낭비하고 있는 자투리 시간을 활용해라. 그리고 핵심을 메모하는 것에 익숙해져라.\n\n## 나의 생각  \n앞으로 나의 책의 메모하는 방식에 큰 변화를 줄 것 같다. 지금까지 했던 메모에는 내 생각이 들어가지 않아서 메모하는 것이 마냥 어렵게 느껴진 것 같다.  \n이후에는 핵심 키워드를 뽑고, 내 생각으로 정리하는 메모법을 적용하겠다.\n\n"},{"fields":{"slug":"/programming/css-tip/","title":"실무에서 배운 CSS 팁"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 실무에서 배운 CSS 팁\ntags:\n  - css\n---\n\n## safari 에서 input disabled 색상이 안보이는 경우\n\n```css\n-webkit-text-fill-color: #880000; // 원하는 색상\nopacity: 1; /* required on iOS */\n```\n\n## flex gap 대신 사용할 수 있는 선택자\n\n일부 브라우져에서는 flex 의 gap 속성이 되지 않는다.\n\n```css\n// before\n.box {\n\tdisplay: flex;\n\tgap: 0 30px\n}\n```\n\n```css\n// after \n.box {\n\tdisplay: flex;\n}\n\n.box > * + * {\n\tmargin-left: 30px;\n}\n```\n\n올빼미 연산자라고 부르는 거 같다.\n\n[https://alistapart.com/article/axiomatic-css-and-lobotomized-owls/](https://alistapart.com/article/axiomatic-css-and-lobotomized-owls/)"},{"fields":{"slug":"/programming/gtm/","title":"Google Tag Mananger"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Google Tag Mananger\ntags:\n  - google tag manager\n---\n\n## 클릭 변수 (click variables) 가 정의되지 않은 경우\n\n흔히 사용하는 변수 중에 `Click Element`, `Click Target` 등의 값이 있다.  \n새로운 컨테이너에서 작업을 하던중 해당 변수가 `undefined` 로 잡히는 경우가 있었다.\n\n우선 클릭 변수는 해당 트리거 중 하나가 활성화 되기전까지는 데이터를 수집하지 않는다.\n\n1. 클릭 - 모든 요소 (All Elements)  \n2. 클릭 - 링크만 (Just Links)\n3. 사용자 참여 - 양식 제출 (Form Submission)\n4. 사용자 참여 - 요소 공개 상태 (Element Visibility)\n\n1 번 클릭 - 모든 요소를 사용하여 모든 요소에 클릭 트리거를 생성해놓으면 클릭 변수를 누락없이 수집할 수 있게된다.\n\n![img.png](../attachments/gtm-2022-09-28.png)\n\n태그 연결 필요없이 해당 트리거만 생성해두면 된다.\n\n\n"},{"fields":{"slug":"/programming/frontend-test/","title":"프론트엔드 테스트"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 프론트엔드 테스트\ntags:\n  - 테스트코드\n---\n\n## 기능의 테스트는 실제 해당 기능을 구현한 곳에서 한다.\n\n컴포넌트를 테스트할 때 실제 해당 기능을 구현한 곳에서 **기능에 대한 테스트**를 진행하고, 나머지 영역에서는 **호출만 테스트**한다.\n\n```jsx\n# App.js\nconst App = () => {\n\tconst [title, setTitle] = useState('');\n\t\n\tconst handleChange = (event) => {\n\t\tsetTitle(event.target.value);\n\t};\n\treturn <Input value={title} onChange={handleChange} />\n}\n\n# App.test.js\n\ntest('input 에 입력 시, 입력값이 input 에 노출된다.', () => {\n  const { container, getByRole } = render(<App />);\n  const input = getByRole('textbox', { name: /할 일/i });\n\n  fireEvent.change(input, { target: { value: 'Study' } });\n  expect(input).toHaveValue('Study');\n});\n```\n\n```jsx\n# Input.js\nconst Input = ({ value, onChange }) => {\n\treturn (<>\n\t\t<label htmlFor=\"input-task-title\">\n      할 일\n    </label>\n\t\t<input \n\t\t\tid=\"input-task-title\"\n\t\t\ttype=\"text\"\n\t\t\tvalue={value}\n      onChange={onChange}\n\t\t/>\n\t</>)\n}\n\n# Input.test.js\n\ntest('입력 시, onChange 함수가 호출된다.', () => {\n\tconst handleChange = jest.fn();\n\tconst { container, getByRole } = render((\n    <Input\n      value={value}\n      onChange={handleChange}\n    />\n  ));\n  const input = getByRole('textbox', { name: /할 일/i });\n\n  fireEvent.change(input, { target: { value: 'hello' } });\n  expect(handleChange).toBeCalled();\n});\n```\n\n## renderComponent 함수 등을 사용해서 반복을 줄인다.\n\n테스트 코드는 말 그대로 어떤 함수의 설명서같은 역할을 한다. 따라서 과도한 고도화는 지양한다. \n\n하지만 테스트 코드를 작성하다보면 컴포넌트 렌더링과, 해당 테스트에서 자주 사용하는 요소를 따로 빼는 것이 이해하는데 도움이 된다고 판단했다.\n\n1. 렌더링 대상\n2. 자주 사용하는 돔 요소\n3. 자주 사용하는 selector 함수\n\n```jsx\nconst renderApp = () => {\n  const { container, getByRole } = render(<App />);\n  const input = getByRole('textbox', { name: /할 일/i });\n\n  return { container, input, getByRole };\n};\n```\n\n## describe ~ context ~ it 을 통해 테스트 시나리오를 작성한다.\n\n**describe** 는 테스트의 주체\n\n**context** 는 따로 비교를 해줘야할 맥락(상황)이 있을 때 선택적으로 사용\n\n**it** 은 실제 테스트하는 내용을 서술한다.\n\n## 테스트 하나하나는 독립적으로 실행된다.\n\n컴포넌트를 테스트하다보면, 앞서 테스트한 선행동작을 사용해야하는 경우가 있는 데, 이때 동기적으로 테스트를 작성하면 안되고, 각각의 테스트는 독립적으로 실행된다고 생각하여 작성해야한다.\n\n그리고 그런 상황에서 해당 테스트 2개가 묶일 수 있는지도 고려해본다.\n\n각각의 테스트를 독립적으로 사용하기 위해 테스트의 시작, 끝 지점에 실행시켜주는 hook을 설정할 수 있다.\n\n```jsx\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n```\n\n## 테스트 명은 비즈니스 명세를 사용한다.\n\n테스트를 작성하다보면, 구현을 테스트으로 작성하는 경우가 있다.\n\n단위테스트를 작성하다보면 자연스러운 일이지만, 지나치게 구현에 대한 설명으로 작성하면 테스트가 깨지기 쉽다.\n\n```jsx\n// Bad\nit('등록 버튼 클릭 시, todoList 배열에 row 1개가 추가된다.', () => {...})\n\n// Good\nit('등록 버튼 클릭 시, 새로운 할일이 추가된다.', () => {...})\n```\n\n## console.log 대신 IDE 의 debugger 사용을 지향한다.\n\n프론트엔드 개발을 진행하다보면 중간중간 값의 결과를 console.log 로 확인하는 경우가 있다.\n\n물론 해당 방법도 디버깅에 많은 도움을 주지만 IDE 의 디버깅 기능을 사용하면 해당 시점의 변수의 값등 여러 기능을 사용할 수 있다.\n\n## 가장 빠르게 문제를 해결할 수 있는 방법으로 변경 후 리펙토링한다.\n\n테스트 코드 작성을 하다보면 오히려 기능을 크게 생각하는 경우가 있다.\n\nTodo list 를 개발한다고 하면, 이미 머리속으로는 할 일을 중앙상태로 관리하고, 관심사를 어떻게 분리하고... 등등 개발에 포커싱을 맞추어 생각하기 마련이다. 이런 생각은 후에 개발이 완료된 이후 테스트 작성을 막막하게 한다.\n\n더 좋은 구조로 코드를 작성하기 위해서는 내가 현재 구현하고자 하는 기능이 명확하게 무엇인지 아는 것이 중요하다.\n\n이때 테스트를 작성한다. 내가 구현하고자 하는 내용을 테스트로 작성하고, 해당 테스트를 가장 빠르게 통과시킬 수 있는 구현에 집중한다. 그 후에 리펙토링한다.\n\n```jsx\ntest('할 일 리스트가 노출된다.', () => {\n  const { container } = render(<App />);\n\t\n\texpect(container).toHaveTextContent('블로그 글쓰기');\n\texpect(container).toHaveTextContent('재미있게 놀기');\n});\n```\n\n위 테스트를 가장 빠르게 해결할 수 있는 방법은 아래 코드이다.\n\n```jsx\nconst App = () => {\n\treturn (<>\n\t\t<span>블로그 글쓰기</span>\n\t\t<span>재미있게 놀기</span>\n\t</>);\n}\n```\n\n위 코드를 작성한 후에 해당 할 일 리스트들을 어떤 방식으로 관리할 지를 고민해서 테스트를 작성하고, 리펙토링한다.\n\n## submit event 를 mocking 할때는 mockImplementaion 을 통해서 preventDefault 메서드를 실행시켜준다.\n\nsubmit 이벤트를 테스트 해야하는 경우에 해당 오류가 발생한다.\n\n```jsx\nError: Not implemented: HTMLFormElement.prototype.submit\n```\n\n아래 방법으로 해결할 수 있다.\n\n```jsx\n// jest.fn 으로 mocking\nconst handleSubmit = jest.fn((event) => {\n\tevent.preventDefault();\n});\n\n// mockImplementation 으로 mocking\nhandleSubmit.mockImplementation((event) => {\n\tevent.preventDefault();\n});\n```\n\n## Container Components 에서는 해당 action이 dispatch 가 잘 되었는지 테스트한다.\n\n리덕스를 사용하는 경우 Container 컴포넌트에서는 mocking한 dispatch가 정확한 액션으로 호출되었는지만 테스트한다. 실제 state 의 변화는 reducer 테스트로 검증하고, 실제 앱에서 해당 데이터가 정확이 노출되는 지는 Presentation Component 에서 테스트한다.\n\n## jest 에서 mock들을 정리하는 방법**\n\n```jsx\n// 각각의 mock 함수에서 mockClear 메서드 실행\nmockFn.mockClear();\n\n// jest 에서 제공하는 clearAllMock 실행\njest.clearAllMocks();\n```\n\n참고자료: [https://haeguri.github.io/2020/12/21/clean-up-jest-mock/](https://haeguri.github.io/2020/12/21/clean-up-jest-mock/)\n\n## jest.unmock 으로 mock 모듈 해제하기\n\njest 에서는 특정 모듈을 mocking 하기 위해서 `__mocks__` 라는 폴더에 mock 들을 구현하고, 이때 jest 설정중에 automock 이 true 로 되어있는 경우는 해당 폴더에 있는 라이브러리 들을 자동으로 mocking 해준다.\n\n## Testing Playground chrome extension\n프론트엔드 테스트를 진행하다보면, getBy~~ 처럼 쿼리를 통해 돔을 찾아내야 하는 상황이 있다.  \n이때 유용한 크롬 확장 프로그램을 이용하면 비교적 쉽게 쿼리를 작성할 수 있다. \n\nhttps://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano\n\n해당 확장 프로그램을 설치한 이후 웹사이트에 들어가 개발자 도구를 열면, Testing Playground 라는 탭이 생겼을 것이다.  \n\n\n![Testing Playground](../attachments/frontend-test-2022-04-28-10-35-45.png)\n\n  \n1번을 클릭하고 2번(원하는 돔)에 마우스를 올리면 해당 돔을 찾을 수 있는 쿼리가 나온다.  "},{"fields":{"slug":"/programming/kotlin/","title":"Kotlin"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Kotlin\ntags:\n  - kotlin\n---\n\n## Basic\n\n### static 메서드 및 객체 정의  \n\nclass 내부에 `companion object` 안에 정의해준다.\n\n```kotlin\nclass Util {\n  companion object {\n      val hello = \"hello\"\n      fun groupByIsNumber(inputs: List<String>, bool: Boolean): List<String> {\n          return inputs.groupBy { (it.toFloatOrNull() != null) }[bool]!!\n      }\n  }\n}\n```\n\n### fold, reduce\nreduce 는 초기값이 배열의 첫번째 원소, fold 는 초기값을 지정할 수 있다.  \n\n```kotest\nclass ListTest : DescribeSpec({\n    describe(\"fold\") {\n        listOf(1, 2, 3).fold(4) { acc, i -> acc + i } shouldBe 10\n    }\n\n    describe(\"reduce\") {\n        listOf(1, 2, 3).reduce { acc, i -> acc + i } shouldBe 6\n    }\n})\n```\n\n### property getter setter\nprivate set\n\n### Enum\n\n\n### values\n\n### ramda\n\n### `?:` 연산식\n\n\n### repeat \n\n### system io\n\n### construct-like functions\n\n### class 종류\ndata, enum, 일반\n\n### 상수화\n\n### require\n\n\n### contract\n\n\n### 스마트 캐스팅\n\n## Test\n\n### shouldThrow\nshouldThrow 를 통해 에러를 테스트할 수 있다.\n\n```\ndescribe(\"사칙연산 기호가 아닌 경우\") {\n  it(\"IllegalArgumentException 에러가 발생한다.\") {\n\n      val calculator = Calculator()\n\n      val exception = shouldThrow<IllegalArgumentException> {\n          calculator.calculate(\"4 $ 2\")\n      }\n\n      exception.message shouldBe \"사칙연산 기호가 아닙니다.\"\n  }\n}\n```\n\n## 알쓸신잡\n\n### const only primitives and string are allowed\nconst 상수는 원시값 및 string 만 허용한다.\n\n## IDEA\n\n### Intellij Kotest 플러그인\n\nIntellij 에서 kotest 를 실행시키기 위해서는 플러그인이 필요하다.\n\n[kotest plugin](https://plugins.jetbrains.com/plugin/14080-kotest)\n\n### Intellij kotlin 테스트 속도 높이기 \n\n설정 -> Build, Execution, Deployment -> Build Tools -> Gradle \n\n기본 Gradle 로 설정되어 있는 값을 intellij 로 변경한다.\n\n![Gradle 설정 변경](../attachments/kotlin-2022-05-07-11-51-10.png)  \n\n\n### 테스트 파일 단숨에 만들기\n테스트를 추가하고자 하는 class 에서 `cmd + shift + t` 입력  \n\n![Create Test](../attachments/kotlin-2022-05-09-10-09-58.png)\n\n원하는 테스트 스펙도 정의할 수 있고, 하단에 테스트를 생성할 메서드도 정의할 수 있다.  \n테스트가 생성된 이후 해당 커맨드를 입력하면 코드와 테스트 코드를 이동할 수 있게 해준다.\n\n### ktlint 로 포맷팅하기\nGradle Toolbar -> Tasks/formatting/ktlintFormat 더블 클릭\n\n![ktlintFormat](../attachments/kotlin-2022-05-09-11-10-46.png)\n\n\n"},{"fields":{"slug":"/programming/meet-error/","title":"내가 만난 에러"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 내가 만난 에러\ntags:\n  - error\n---\n\n## The pseudo class \":first-child\" is potentially unsafe when doing server-side rendering. Try changing it to \":first-of-type\".\n\n리액트 프로젝트를 실행시킬 때 console.error 로 해당 에러가 발생하였다.\n\n원인은 SSR 을 하게될 시에 style element 도 함께 렌더링이 되는데, 이떄 `:first-child` 가 style element 가 될 수도 있어서 보여주는 경고이다.\n\n참고 링크: https://github.com/emotion-js/emotion/issues/1059#issuecomment-444566635"},{"fields":{"slug":"/programming/nextjs-config/","title":"Next.js config"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Next.js config\ntags:\n- React\n- Nextjs\n- config\n---\n\n### base path \n\nsub-path 도메인으로 어플리케이션을 서빙하고 싶을때 basePath 옵션을 통해 sub-path 를 설정할 수 있다.\n\n```js\nmodule.exports = {\n  basePath: '/new'\n}\n```\n\n> nextjs 의 base path 설정으로 인해 `mockServiceWorker.js` 를 불러오지 못함\n\n[관련 링크](https://github.com/mswjs/msw/issues/690#issuecomment-849552403)\n\n```js\n// next.config.js\nmodule.exports = {\n  basePath: '/prefix',\n  async headers() {\n    return [\n      {\n        // Append the \"Service-Worker-Allowed\" header\n        // to each response, overriding the default worker's scope.\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'Service-Worker-Allowed',\n            value: '/',\n          },\n        ],\n      },\n    ]\n  },\n}\n\n// ...\n\nworker.start({\n  serviceWorker: {\n    // Specify the worker script URL relative to the _root_.\n    url: '/prefix/mockServiceWorker.js',\n    options: {\n      // Override the scope to the root (\"/\").\n      // By default, the worker is scoped to its location on your server,\n      // which in this case would be \"/prefix\".\n      scope: '/',\n    },\n  },\n})\n```\n\n### rewrites\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"fields":{"slug":"/programming/nextjs/","title":"Next.js"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Next.js  \ntags:\n- React\n- Nextjs\n---\n\n## Data Fetching\n\n### getInitialProps  \nserver side rendering \n\n### getServerSideProps\nserver side rendering\n\n### getStaticPath\nDynamic routes 를 할 때 path 리스트를 생성\n\n#### fallback \n빌드 과정에 존재하지 않았던 static 파일에 대한 처리 옵션\n\n존재하지 않는 static 파일 접속 시, \n- false 인 경우(default), 404 에러 발생\n- true 인 경우, 해당 페이지의 getStaticProps 를 실행하여 데이터를 가져온 후 static file 을 생성함\n  - 이때 router 의 isFallback 을 true 로 변환 후 페이지 렌더링\n```tsx\nimport { useRouter } from 'next/router'\n\nfunction Post({ post }) {\n  const router = useRouter()\n\n  if (router.isFallback) {\n    return <div>Loading...</div>\n  }\n}\n```\n- 'blocking' 인 경우, 해당 해당 페이지의 getStaticProps 를 실행하여 데이터를 가져온 후 static file 을 생성함\n  - getStaticProps 의 응답을 기다린 후 페이지 렌더링\n\n상위 1 ~ 50 개의 페이지를 빌드 과정에 미리 생성하고, 나머지는 fallback 을 통해 요청 당시에 생성하는 방식을 사용하면 좀 더 효율적으로 앱을 운용할 수 있음\n\n### getStaticProps\nSSG  \n\n---\n\n## Rendering\n\n### Server side Rendering (SSR)  \n서버에서 데이터 패칭 후 페이지를 그려줌\n새로고침마다 데이터를 가져옴\n\n### Static Site Generation (SSG)\n정적인 사이트 생성  \ngetStaticProps (getStaticPaths) 를 통해 데이터를 Fetch 해옴  \n빌드 과정에 데이터를 Fetch 해서 페이지를 생성  \n\n`yarn dev` 명령에서는 SSR 과 동일하게 동작하고, `yarn build`, `yarn start` 에서는 SSG 가 정상 동작  \n\n`getStaticPaths` 는 동적 path 에서 getStaticProps 로 만들어질 데이터가 무엇인지 알려줌\n\n### Incremental Site Regeneration (ISR)\n\nSSG 와 비슷하게 동작, revalidate 옵션으로 페이지를 다시 만들어낼 주기를 설정\n\n```js\nexport async function getStaticProps() {\n  return {\n    props: { time: new Date().toISOString() },\n    revalidate: 10,\n  }\n}\n```\n10 초에 한 번씩 페이지를 새로 만들어냄\n\n### Pre-rendering\ngetServerSideProps / getStaticProps 에서 데이터를 미리 만들어 놓고 내려주는 방식\n따라서 페이지 렌더링 후 js 를 로드하여 데이터를 가져오는 CSR 방식에 비해, SEO 에 유리함  \n\n---\n\n## 최적화\n\n### 코드 스플릿팅  \n하나의 번들을 여러개의 파일로 나누어, 실제 로드에 필요한 번들 파일만 불러 올수 있도록 함\n\n### 이미지 옵티마이징\n[Next/Image를 활용한 이미지 최적화](https://fe-developers.kakaoent.com/2022/220714-next-image/)  \n[Image Component and Image Optimization](https://nextjs.org/docs/basic-features/image-optimization)\n\n현재 기기의 해상도에 따라 이미지의 해상도를 다르게 로딩할 수 있음\n\n### 파일 기반 라우팅  \npages 하위에 있는 파일들이 라우팅됨, 동적 라우팅을 사용할 수도 있음\n\n### SEO\n...\n\n### Serverless Functions\nAWS 의 람다 와 동일, Vercel 에서는 Serverless Functions 이라고 부름\n\n---\n\n## 동적 임포트 (Dynamic Import)\n`next/dynamic` 을 통해서 동적 임포트를 지원\n\n**Example**\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst DynamicHeader = dynamic(() => import('../components/header'), {\n  suspense: true,\n})\n\nexport default function Home() {\n  return (\n    <Suspense fallback={`Loading...`}>\n      <DynamicHeader />\n    </Suspense>\n  )\n}\n```\n\n### Suspense\n\nsuspense 옵션을 통해서 `Suspense` 기능을 사용\n\n```js\nconst DynamicHeader = dynamic(() => import('../components/header'), {\n  suspense: true, // \n})\n```\n\nReact 18 이전에는 suspense 대신 loading 옵션을 사용\n\n```js\nconst DynamicHeader = dynamic(() => import('../components/header'), {\n  loading: () => <div>Loading...</div>,\n})\n```\n\n### named export\n\n동적 임포트하는 파일의 특정 컴포넌트를 import 하고 싶다면 Promise then 을 사용\n\n```js\n// components/hello.js\nexport function Hello() {\n  return <p>Hello!</p>\n}\n\n// pages/index.js\nconst DynamicComponent = dynamic(() =>\n  import('../components/hello').then((mod) => mod.Hello)\n)\n```\n\n### Client Side Rendering\n동적 임포트를하는 컴포넌트를 CSR 방식으로 사용하고 싶다면 ssr 옵션을 false 로 주면 된다.\n\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst DynamicHeader = dynamic(() => import('../components/header'), {\n  ssr: false,\n})\n```\n--- \n## Shallow Routing\ngetServerSideProps / getStaticProps 를 실행시키지 않고,\n현재 상태를 잃지 않고 url 를 변경할 수 있음\n\nShallow Routing 은 **현재 페이지 URL 변경에서만 작동**  \n\n### url 을 변경시키는 3가지 방법\n\n1. location.replace(\"url\"): 로컬 state 유지 안됨 (리렌더)\n2. router.push(url): state 유지 / data fetching O\n3. router.push(url, as, { shallow: true }): state 유지 / data fetching X\n\n---\n\n## Link Component\n클라이언트 단에서 페이지 이동을 할 때 사용하는 컴포넌트\n\n```jsx\nimport Link from 'next/link'\n\nfunction Home() {\n  return (\n    <ul>\n      <li>\n        <Link href=\"/\">Home</Link>\n      </li>\n    </ul>\n  )\n}\n\nexport default Home;\n```\nLink 컴포넌트에 스타일을 주고 싶다면, Link 컴포넌트 안에 a 태그를 넣어주고 해당 a 태그에 스타일을 적용하면 된다.\n\n### Link 컴포넌트의 자식으로 a 태그 커스텀 컴포넌트를 사용한 경우\n\npassHref 옵션을 사용해야한다. 해당 속성을 넣지 않으면 a 태그에 href 속성이 없어 SEO 에 안좋다.\n\n```tsx\nconst StyledLink = styled.a`\n  color: red;\n`\n\nfunction Home() {\n  return (\n    <ul>\n      <li>\n        <Link href=\"/\" passHref>\n          <StyledLink>링크</StyledLink>\n        </Link>\n      <li>\n    </ul> \n  )\n}\n``` \n\n### Link 컴포넌트의 자식으로 함수형 컴포넌트를 사용한 경우\n해당 함수형 컴포넌트는 forwardRef 를 사용해야한다.  \n\n### Link 컴포넌트에 적용된 최적화\n\n**Client side navigate**  \n기존 a 태그와 다른 점은 페이지를 이동할 때 필요한 리소스만 호출해서 JS 상에서 페이지를 이동시킨다.  \n따라서 해당 페이지내 리소스가 아닌 외부 링크로 가는 경우에는 a 태그를 사용해도 무방함  \n\n**Prefetching**  \nLink 컴포넌트가 viewport 에 들어오면 해당 페이지의 리소스를 미리 불러온다.   \n`yarn start` 에서만 동작  \n\n## Image 컴포넌트\n\n### Image 컴포넌트에 적용된 최적화\n\n**Resizing**  \n기기의 크기에 맞게 이미지 리소스를 리사이징  \n모바일 환경에서 이미지 리소스 크기를 줄여줌\n\n**Lazy loading**\nviewport 에 해당 컴포넌트가 노출되었을 때 이미지를 불러옴  \n화면에 노출되지 않은 이미지 리소스를 불러오지 않아 유리함  \n\n## Code Splitting\n애플리케이션의 번들을 각 진입점에 필요한 더 작은 청크로 분활하는 프로세스\n특정 페이지를 실행하는 데 필요한 코드만 로드하여 애플리케이션의 초기 로드 시간을 개선\n\n## Next.js Compiler\n\n### SWC\nRust 기반의 속도가 빠른 컴파일러  \n\n```\n// next.config.js\nmodule.exports = {\n  swcMinify: true,\n}\n```\n\n### 유용한 Features\n\n**Remove Console**\n\n`console.*` 호출을 제거해준다. \n\n```typescript jsx\n// next.config.js\nmodule.exports = {\n  compiler: {\n    removeConsole: true,\n  },\n}\n\n\n// console.error 는 제외\nmodule.exports = {\n  compiler: {\n    removeConsole: {\n      exclude: ['error'],\n    },\n  },\n}\n```\n\n**Remove React Properties**  \njsx property 를 제거하는 기능  \ndefault 로 `^data-test` 를 제거함 (테스트를 위한 속성 제거)  \n\n```typescript jsx\n// next.config.js\nmodule.exports = {\n  compiler: {\n    reactRemoveProperties: true,\n  },\n}\n\n// 특정 property 제거\n// next.config.js\nmodule.exports = {\n  compiler: {\n    reactRemoveProperties: { properties: ['^data-custom$'] },\n  },\n}\n```\n\n**Modularize Imports**\n\n많은 npm packages 들이 \"barrel files\" 를 사용하여 하나의 파일로 서빙하고 있음\n이때 사용하지 않는 barrel file 에 선언된 re-exported files dp 대해서도 컴파일이 돌아감\n\n\n\n\n\n## Preview Mode\n"},{"fields":{"slug":"/programming/react-query/","title":"React Query"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: React Query\ntags:\n  - React\n---\n\n## 개요\n\n서버 상태와 클라이언트 상태를 분리한다.  \n클라이언트에서 관리하는 상태는 그렇게 많지 않다.\n\n## SSR\n\nqueryClient 에 데이터를 전달하는 방법을 사용\n\n- initialData 를 이용하는 방법\n\n## react-query 는 동시에 나가는 요청의 중복을 제거한다.  \n각각의 컴포넌트에서 useQuery 를 사용하더라도, 동일한 요청에 관해서는 중복을 제거한다.\n\n\n## useQuery 의 isFetching 과 isLoading 의 차이\n\n- isFetching\n    - 캐시된 데이터가 존재하는 상태\n    - query 함수가 아직 resolve 되지 않았다.\n- isLoading\n    - 캐시된 데이터가 없고 + isFetching\n\n\n## Stale Time 과 Cache Time 의 차이\n\n- A 쿼리 인스턴스가 mount 됨\n- 네트워크에서 데이터 fetch 하고 A라는 query key로 캐싱함\n- 이 데이터는 `fresh` 상태에서 `staleTime`(기본값 0) 이후 `stale` 상태로 변경됨\n- A 쿼리 인스턴스가 unmount 됨\n- 캐시는 `cacheTime`(기본값 5min) 만큼 유지되다가 가비지 콜렉터로 수집됨 → 이때 캐시된 데이터도 사라짐\n- 만일 `cacheTime`이 지나기 전에 A 쿼리 인스턴스가 새롭게 mount되면, fetch가 실행되고 `fresh`한 값을 가져오는 동안 캐시 데이터를 보여줌\n  \n\n### 상태별 특징\n\nfresh 상태에서는 아무리 새롭게 마운트를 해도 fetching 이 일어나지 않음\n\nfetching 은 데이터를 가져오는 중인 상태 → 캐시된 데이터가 있으면 그 데이터를 사용할 수 있음\n\n\n**Stale Time (기본값: 0)**\n\n데이터가 fresh 에서 stale 까지 걸리는 시간\n\n**Cache Time (기본값: 5min)**\n\n데이터가 inactive 상태에서 Cache Time 만큼 유지된 이후에 가비지 콜렉터로 수집된다.\n\n## Stale Time 이 0인 이유\n\n0으로 설정함으로써 서버에서 가져온 데이터가 항상 오래된 데이터라고 생각하는 것이 맞다.\n\n그래야지 항상 최신 상태를 유지할 수 있기 때문이다.\n\n## Pre Fetching\n\n좀 더 좋은 UX 를 보여주기 위해 다음에 가져올 데이터를 미리 가져오는 방법\n\nqueryClient 의 prefetchQuery 를 이용해서 다음 데이터를 미리 가져올 수 있다.\n\n```typescript\nuseEffect(()=>{\n  if(currentPage >= maxPostPage) {\n    return;\n  }\n  const nextPage = currentPage + 1;\n  queryClient.prefetchQuery([\"posts\",nextPage],()=> fetchPosts(nextPage))\n},[currentPage,queryClient])\n```\n\n## useQuery의 keepPreviousData\n\nuseQuery 의 `keepPreviousData` 옵션을 통해 쿼리키가 변경된 경우 새 데이터를 요청하는 동안 마지막으로 성공한 요청의 데이터를 사용할 수 있다.\n\n## Mutation\n\n네트워크 호출을 통해 서버의 값을 변경하는 것\n\n## useInfiniteQuery\n\n무한 스크롤 구현을 좀 더 편하게 해주는 쿼리 훅\n\n```jsx\nconst {\n  data: {\n    pages, // 실제 페이지 데이터 배열 [0, 1, 2, 3] 각각의 배열 인덱스에 맞춰서 데이터가 들어가 있음\n    pageParams // 다음 페이지 url 및 param 정보 -> getNextPageParam 의 리턴 값\n  }, \n  fetchNextPage, // 다음 페이지 fetching 하는 함수\n  hasNextPage, // 다음 페이지가 있는 경우 참\n  isLoading, // 로딩 시 참\n  isFetching, // 데이터 fetching 시 참\n  isError // 에러 발생시 참\n} = useInfiniteQuery(\n  [\"sw-people\"], ({pageParam = initialUrl}) => {\n    console.log(pageParam);\n    return fetchUrl(pageParam)\n  },\n  {\n    getNextPageParam: lastPage => lastPage.next || undefined\n  }\n)\n```\n\n## useIsFetching\n\nreact query 커스텀 훅으로 현재 queryClient 들의 isFetching 상태를 가져올 수있다.\n\n## Default Error Handling\n\n해당 프로젝트의 특성에 맞게 전역에서 에러를 핸들링\n\n```jsx\nnew QueryClient({\n  defaultOptions: {\n    queries: {\n      retry: 0,\n      onError: (error: unknown) => {\n        // error handling \n      },\n    },\n  },\n});\n```\n\n이렇게 등록하고 커스텀 해야하는 곳에서만 별도의 onError 를 설정\n\n## 데이터를 미리 채우는 메서드 및 옵션들\n\n|  | 어떻게 사용 | 어디서 오는 데이터? | 캐시가 되는지 |\n| --- | --- | --- | --- |\n| prefetchQuery | queryClient 의 메서드 | server | true |\n| setQueryData | queryClient 의 메서드 | client | true |\n| placeholderData | useQuery 의 옵션 | client | false |\n| initialData | useQuery 의 옵션 | client | true |\n\n## PrefetchQuery 를 이용해 미리 데이터 가져오기\n\n만약 80퍼센트의 유저가 홈페이지 방문후 강의 리스트 페이지로 간다면, \n\n홈페이지 컴포넌트에서 강의 리스트를 prefetch 해 놓는다.\n\n## select 를 통해 가져온 데이터 커스텀하기\n\nuseQuery 의 select 옵션을 통해 가져온 데이터를 커스텀할 수 있다.\n\n```jsx\n{ select: showAll ? undefined : selectFn }\n```\n\nundefined 시에는 현재 캐시 데이터를 그래도 반환하고, 함수가 등록된 경우에는 해당 함수의 리턴을 반환한다.\n\n## Re-fetching 을 하는 이유와 시점\n\n새로운 데이터를 서버로 부터 받아오기 위해서 특정 시점에 refetching 을 한다.\n\n시점\n\n- 새로운 쿼리 인스턴스가 마운트 될때\n- 리액트 컴포넌트가 mount 될때\n- 창이 포커싱 될때\n- 네트워크가 다시 연결 될때\n- refetchInterval 이 expired 될때\n    - polling\n    \n\n## Re-fetching 을 피하는 방법\n\n- staleTime 늘리기\n    - refetch 은 데이터가 stale 상태인 경우에만 요청하기 때문에 fresh 상태의 데이터를 오래 놔둔다.\n- refresch option 들 끄기\n    - 여러가지 refresh 옵션들이 존재하는데 이들을 끄면 된다.\n- 정말 한번 가져오면 정말 안가져와도 되는 데이터들은 조금 관리해줘도 괜찮을 것 같음\n\n## 전역 refetch option\n\nqueryClient에 설정가능\n\n```jsx\nnew QueryClient({\n  defaultOptions: {\n    queries: {\n      retry: 0,\n      onError: (error: unknown) => {\n        queryErrorHandler(error);\n      },\n      refetchOnMount: false,\n      refetchOnWindowFocus: false,\n      refetchOnReconnect: false,\n    },\n  },\n});\n```\n\n## queryClient.setQueryData\n\n쿼리 키 기반으로 클라이언트 캐시 데이터를 업데이트 시킨다. \n\n```jsx\nqueryClient.setQueryData(queryKey, updater)\n```\n\n## queryClient.getQueryData\n\n쿼리 키 기반으로 클라이언트 캐시 데이터를 반환한다. 제네릭으로 리턴하는 값의 타입을 지정할 수도 있다.\n\n## getQueryData VS useQuery  \n\n해당 Discussions 링크를 첨부한다.  \n[What is the best (or alternate) ways to fetch the server data from a child component when the parent component hits an api that returns all the data that we need?](https://github.com/tannerlinsley/react-query/discussions/1619)\n\n데이터가 필요한 컴포넌트에서 직접 useQuery 를 요청하는 것을 권장한다.\n\n## query 의 onSuccess 가 울리는 시점\n\n- queryClient 의 setQueryData\n- query 인스턴스 생성\n\n이로인해 알게된 사실은 모든 API fetching 을 useQuery 로만 해결하는 것이 아니라, api의 성공 응답에 setQueryData 를 해도 괜찮다.\n\n아래 예제 같은 경우에도 login, logout 하는 API 는 별도로 존재하고, 해당 API 의 성공 콜백에서 setQueryData 를 진행하였다.\n\n```jsx\nexport function useUser(): UseUser {\n  // TODO: call useQuery to update user data from server\n  const queryClient = useQueryClient();\n  const { data: user } = useQuery(queryKeys.user, () => getUser(user), {\n    onSuccess: (received: User | null) => {\n      console.log({ received });\n      if (!received) {\n        clearStoredUser();\n      } else {\n        setStoredUser(received);\n      }\n    },\n  });\n\n  // meant to be called from useAuth\n  function updateUser(newUser: User): void {\n    queryClient.setQueryData(queryKeys.user, 'hello');\n  }\n\n  // meant to be called from useAuth\n  function clearUser() {\n    queryClient.setQueryData(queryKeys.user, null);\n  }\n\n  return { user, updateUser, clearUser };\n}\n```\n\nupdateUser 를 실행시켰을 때 useQuery 의 onSuccess 콜백이 실행된다.\n\n## query 의 initialData 를 이용해서 쿼리 인스턴스의 초기 데이터를 셋팅한다.\n\ninitialData 는 일반 값 객체가 될 수도 있고, 함수 형태로 리턴 값을 넣을 수도 있다.\n\n[Initial Query Data](https://react-query.tanstack.com/guides/initial-query-data#using-initialdata-to-prepopulate-a-query)\n\n```jsx\nfunction Todo({ todoId }) {\n   const result = useQuery(['todo', todoId], () => fetch('/todos'), {\n     initialData: () => {\n       // Use a todo from the 'todos' query as the initial data for this todo query\n       return queryClient.getQueryData('todos')?.find(d => d.id === todoId)\n     },\n   })\n }\n```\n\ninitialData 에서 기존 queryClient 의 값을 가져와서 보여주는 것도 가능하다.\n\n## query 의 enabled 옵션을 이용해서 의존성 쿼리 인스턴스를 만든다.\n\n[https://react-query.tanstack.com/guides/dependent-queries](https://react-query.tanstack.com/guides/dependent-queries)\n\n```jsx\nconst{data: userAppointments = fallback}= useQuery(\n\t'user-appointments',\n\t()=> getUserAppointments(user),\n\t{\n\t\tenabled: !!user,\n\t},\n);\n```\n\n## queryClient 의 removeQueries 는 쿼리 인스턴스를 제거한다.\n\ndevtool 로 확인한 결과 쿼리 클라이언트 자체를 제거한다.\n\nsetQueryData null 과 removeQueries 와 동작이 비슷하지만, setQueryData 는 쿼리의 onSuccess 함수를 호출한다는 것에 의미가 있다.\n\n## mutation 전역 에러 헨들링\nquery 와 비슷하게 QueryClient 인스턴스를 생성하는 과정에서 전역 에러 핸들링을 추가할 수 있다.\n\n```typescript\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    ...,\n    mutations: {\n      onError: queryErrorHandler\n    }\n  }\n})\n```\n\n## 전역 mutation loading 은 `useIsMutating` 을 사용한다.\n\n```jsx\nexport function Loading(): ReactElement {\n\tconst isFetching = useIsFetching();\n  const isMutating = useIsMutating();\n\n  const display = isFetching || isMutating ? 'inherit' : 'none';\n  \n  return <Loading {display} />\n}\n\n```\n\n\n## useMutation 과 useQuery 의 차이점\n\n- 캐시 데이터가 없음 (no cache data)\n- 재시도가 없음 (no retries)\n- 재패치가 없음 (no refetch)\n- isFetching 이 없음 (캐시 데이터가 없기 때문에, 모든 로딩은 isLoading 으로 판별)\n- mutate 함수를 리턴하고 mutate 함수가 실행될 때 동작한다.\n- onMutate callback 존재\n\n## UseMutateFunction의 제네릭\n\n```jsx\nUseMutateFunction<TData, TError, TVariables, TContext>\n\nTData: mutate 의 리턴 타입\nTError: mutate 의 에러 타입\nTVariables: mutate 함수의 인자 타입\nTContext: onMutate 콜백의 인자 타입\n```\n\n## UseMutateFunction 사용 예시\n```typescript\nfunction useReserveAppointment(): UseMutateFunction<void, Error, Appointment, unknown> {\n  const { mutate } = useMutation((appointment: Appointment) => setAppointmentUser())\n\n  return mutate;\n}\n```\n\n## queryClient.invalidateQueries\n쿼리를 무효화 시켜 새로운 쿼리 데이터를 fetching 한다.\n\ninvalidateQueries 의 효과  \n- query 를 stale 상태로 만든다.\n- 만약 현재 렌더링 중이라면 re-fetch 한다.\n\n## Query Key Prefixes\nuseQuery 의 쿼리키의 기준 잘 설정해서, invalidateQueries 를 할떄 그룹핑하는 방법이 있다.\n\n예를 들어, 해당 mutate 성공 시 user 관련 쿼리들을 일괄 invalidateQueries 를 해야된다고 할때 유용하다.\n\n## onSuccess 로직에서 return 을 하면 await 처럼 동작한다.\n\nonSuccess 로직에서 return 을 사용하게 되면 await 를 건것처럼 동작하게 된다.\n```jsx\n{\n  {\n    onSuccess: () => {\n      return queryClient.refetchQueries('todos'); // 해당 refetch 가 성공했을 때 이후 로직이 수행된다.\n    }\n  }\n\n  {\n    onSuccess: () => {\n      queryClient.refetchQueries('todos'); // void 처럼 동작함\n    }\n  }\n}\n```\n\n\n## infiniteQuery 에서는 invalidateQueries 가 동작하지 않는 것 같다.\nmutate 이후에 onSuccess 로직에서 infiniteQuery 를 invalidate 해야하는 일이 있었다.\n(상세페이지에서 좋아요를 누르고, 다시 리스트 페이지로 이동한 경우)\n\n하지만 infiniteQuery 가 invalidate 상태로 변하지 않았다.\n\nhttps://github.com/tannerlinsley/react-query/discussions/1264\n\n쓰레드로 확인했을 때 제작자분은 되는게 정상이라고 하시는데, 나는 잘 되지 않았다.\n\n그래서 임시방편으로 refetchQueries 를 사용했다.\n\n\n## mutate 와 useMutation 에 onSuccess 로직\nmutation 이 성공했을때의 로직을 담을 수 있는 함수인 onSuccess 는 useMutation 의 세 번쨰 인자 or onSuccess 의 두 번째 인자로 넘길 수 있다. \n\n```js\n const {\n   mutate,\n } = useMutation(mutationFn, {\n   onSuccess,\n })\n \n mutate(variables, {\n   onSuccess: () => {\n\n   },\n })\n```\n\n## useMutation 의 동작\n**onMutate**\nmutation 이 시작하였을 때\nmutation 에서 return 하는 값은 해당 mutation 에서 context 로 참조가 가능하다.\n\n**onError**\n에러가 발생했을 때\n\n**onSuccess**\n성공했을 때\n\n**onSettled**\nmutation 이 끝났을 때, 성공 or 실패 에 상관없이 실행됨\n\n```jsx\nuseMutation(addTodo, {\n  onMutate: variables => {\n    return { id: 1 };\n  },\n  onError: (error, variables, context) => {\n    console.log(`에러 발생: ${context.id}`);\n  },\n  onSuccess: (data, variables, context) => {\n    console.log('성공');\n  },\n  onSettled: (data, error, variables, context) => {\n    console.log('mutation 끝남');\n  },\n});\n```\n\n## onSuccess 의 인자\n**data**\nAPI 응답 값\n\n**variables**\nmutate 함수 실행 인자\n\n**context**\nonMutate 함수에서 return 한 값\n\n\n```jsx\nonSuccess: (data, variables, context) => {\n  console.log('성공');\n}\n```\n## useQuery 사용시 isLoading 과 data 유무를 전부 확인해야한다.\n간혹 useQuery 를 사용할 때 단순히 isLoading 으로만 데이터 유무를 판단할 때가 있었다.\n\n```jsx\n\n\nconst { data, isLoading } = useQuery();\n\nif (isLoading) { // fetching 끝난후\n  return <div>Loading 중...</div>\n}\n\nreturn (\n  <div>{data?.hello}</div>\n)\n```\n\n이렇게 되는 경우 API 가 실패한 경우 해당 컴포넌트 에러가 발생한다.\n데이터를 fetching 하는 동안 isLoading 이 true 가 된다.\n\n이후 API 가 실패해서 데이터가 정상적으로 불러와지지 않은 상태에서 isLoading 은 false 가 되고, data는 undefined 가 된다.\n\n`data.hello` 에서 에러가 발생한다.\n\n따라서 isError 혹은 data 의 유무와 같은 적당한 분기가 필요하다.\n\n## Optimistic Updates\n직역하면 낙관적 업데이트로, 사용자의 요청이 오면 즉시 해당 UI 를 업데이트 시키고, 이후 서버의 응답으로 업데이트 혹은 UI 롤백을 시키는 방법이다.  \n좋아요를 눌렀을 때 사용하기 좋다.\n\n```jsx\nuseMutation(updateTodo, {\n  // mutate 실행\n  onMutate: async newTodo => {\n    // cancelQueries 를 통해 혹시 실행되고 있는 refetch 를 취소한다.\n    await queryClient.cancelQueries(['todos', newTodo.id])\n\n    // 기존 데이터 가져오기\n    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])\n\n    // 낙관적 업데이트\n    queryClient.setQueryData(['todos', newTodo.id], newTodo)\n\n    // 해당 mutation 에서 사용할 context 리턴\n    return { previousTodo, newTodo }\n  },\n  // 에러 발생 시 기존에 업데이트 했던 데이터 되돌리기\n  // 이때 onMutate 에서 리턴한 값을 세번째 인자인 context 에서 사용할 수 있음\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(\n      ['todos', context.newTodo.id],\n      context.previousTodo\n    )\n  },\n  // 성공 or 실패 이후에 쿼리 리패치\n  onSettled: newTodo => {\n    queryClient.invalidateQueries(['todos', newTodo.id])\n  },\n})\n```\n\n## setLogger\nreact query 에서 발생하는 로그를 setLogger 함수를 통해 커스텀할 수 있다.  \n사내에서는 윈스턴을 사용하니 전역적으로 설정하면 도움이 될 것 같다. \n\n```jsx\nimport { setLogger } from 'react-query'\nimport { printLog, printWarn, printError } from 'custom-logger'\n\n// Custom logger\nsetLogger({\n  log: printLog,\n  warn: printWarn,\n  error: printError,\n})\n\n// Winston logger\nsetLogger(winston.createLogger())\n```\n\n## Query Test 는 msw와 react-testing-library 를 사용한다.\njest 환경에서 msw 를 셋팅하여 테스트하면 실제 API 통신을 목킹할 수 있다.\n\nmsw 는 튜토리얼이 잘되어 있어 설치 및 작성 방법은 아래 공식문서를 참고한다.\nhttps://mswjs.io/\n\nmsw 에서 지정한 헨들러를 통해 테스트 코드에서 네트워크 통신을 목킹한다.\n\n**req**  \n요청, 요청에 관련된 정보가 담겨있는 object\n\n**res**  \n응답, mocked response 생성을 도와주는 함수\n\n**ctx**  \nstatus code 나 headers, body, 등등을 셋팅할 수 있는 인스턴스\n\n```js\nconst worker = setupWorker(\n  rest.post('/login', (req, res, ctx) => {  ctx   \n    const { username } = req.body\n    return res(\n      ctx.json({\n        username,\n        firstName: 'John'\n      })\n    )\n  }),\n)\n```\n\n## mutate 는 onSuccess 는 해당 컴포넌트가 마운트가 해제되면 울리지 않는다.\n\n[관련 링크](https://stackoverflow.com/questions/70662482/react-query-mutate-onsuccess-function-not-responding)\n\n강의실 개선 작업을 하다 해당 수업의 시청 여부를 체크하는 컴포넌트에서 사용한 `mutate` 의 `onSuccess` 가 실행되지 않는 버그가 발생했다.\n\n문제의 원인은 `mutate` 를 사용한 컴포넌트가 mutate 성공 이후에 마운트를 헤제하는 로직으로 작성되어 있었다.\n\n해당 `mutate` 함수를 부모에서 실행하고, 자식한테 props 로 해당 함수를 넘겨주는 방식으로 작성하니 해결되었다.\n\n\n\n"},{"fields":{"slug":"/programming/rollup-config/","title":"rollup config"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: rollup config\ntags:\n- rollup\n- config\n---\n\n### output\n```js\n{\n    output: {\n      entryFileNames: `[name].[hash].js`,\n      chunkFileNames: `[name].js`,\n      assetFileNames: `[name].[ext]`\n    }\n}\n```\n"},{"fields":{"slug":"/programming/shaka-player-error-4000/","title":"shaka-player Error 4000"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: shaka-player Error 4000\ntags:\n- library\n- shaka-player\n- 트러블슈팅\n---\n\n## 문제 상황\n\nshaka-player 로 m3u8 파일을 재생하는 과정중에, Error code 4000 이 발생했다.  \n해당 에러는 `UNABLE_TO_GUESS_MANIFEST_TYPE` 라는 에러로 manifest 파일의 타입을 추측할 수 없다는 에러였다.\n\n## 해결 과정\n\n우선 shaka player 를 통해 load 하는 메서드에서 manifest 파일의 타입을 명시적으로 지정해주었다.\n\n```javascript\nconst player = new shaka.Player(videoElement);\n\n/**\n * @param {string} uri\n * @param {number=} startTime\n * @param {string=} mimeType\n */\nplayer.load('http://example.com/manifest.m3u8', 0, 'application/x-mpegurl');\n```\n\n에러에 대한 자세한 내용은 아래와 같다.\n> The Player was unable to guess the manifest type based on file extension or MIME type. To fix, try one of the following:  \n> - Rename the manifest so that the URI ends in a well-known extension.  \n> - Configure the server to send a recognizable Content-Type header.  \n> - Configure the server to accept a HEAD request for the manifest.  \n> \n> error.data[0] is the manifest URI.\n\n### Rename the manifest so that the URI ends in a well-known extension.\nURI가 잘 알려진 확장자로 끝나도록 매니페스트의 이름을 바꿉니다. -> 이미 m3u8 확장자로 되어있음\n\n### Configure the server to send a recognizable Content-Type header.\n서버가 인식 가능한 Content-Type 헤더를 보내도록 서버를 구성합니다.\n![](.shaka-player-error-4000_images/92edbb59.png)\n\n문제가 발생하는 m3u8 파일의 Content-Type 을 확인해보니 `text/plain` 으로 되어있었다.\n\n## 해결 방법\n확인해보니 s3에 업로드를 할 때, Content-Type 을 지정해서 업로드를 할 수 있다고 한다.  \n이미 인코딩되어서 업로드를 했기 때문에, 해당 파일을 다시 업로드할수는 없었고, aws lambda 를 통해서 m3u8 파일의 response header 의 Content-Type 을 `application/x-mpegurl` 로 변경하는 작업을 했다.\n\n```javascript\n'use strict';\n\nexports.handler = (event, context, callback) => {\n  const response = event.Records[0].cf.response;\n  \n  response.headers['content-type'] = [{ key: 'Content-Type', value: 'application/x-mpegurl' }];\n  \n  callback(null, response);\n};\n```\n\n\n"},{"fields":{"slug":"/programming/shaka-player-typescript/","title":"shaka player using typescript"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: shaka player using typescript\ntags:\n- library\n- shaka-player\n---\n\n## 문제 상황\n현재 사내에서 사용하는 라이브러리 중에 javascript media 라이브러리인 [shaka-player](https://github.com/shaka-project/shaka-player) 를 사용하고 있다.\n해당 라이브러리를 사용하는 프로젝트는 typescript 로 작성되어 있기 때문에, shaka-player 를 typescript 로 사용하기 위한 방법을 찾아보았다.\n\n## 해결 과정\n\n관련한 이슈가 github 에 올라와 있다.\nhttps://github.com/shaka-project/shaka-player/issues/1030\n\n> We looked into switching over to Typescript before, but decided to stick with Closure. I'll have to consult with Joey about adding Typescript support. If we have to maintain declarations files in addition to our existing externs, it'll probably add a lot of maintenance, so we'll see.\n\nshaka 내부 구현이 Closure 로 되어 있기때문에 typescript 도입에 대한 이슈가 있는것 같다.\n\n## 해결 방법\n\n아라에 custom type declaration 을 추가하는 방법이 나와있어서 해당 방법을 사용했다.\n\n```typescript\n// @types/shaka-player/index.d.ts\n\ndeclare module 'shaka-player' {\n  export = shaka;\n}\n\ndeclare module 'shaka-player/dist/shaka-player.compiled' {\n  export = shaka;\n}\n```\n\n## 미해결 난제\ntsup 을 통해서 해당 shaka-player 를 포함하고 있는 파일을 빌드하려고 했으나, --dts 옵션을 사용하면 해당 라이브러리의 type declaration 이 빌드되지 않는다.\n```sh\ntsup src --dts\n```\n\n해당 이슈에 대한 해결 방법을 찾아보고 있다.\n```sh\nError: namespace child (hoisting) not supported yet\n\n  1 | declare module 'shaka-player' {\n> 2 |   export = shaka;\n    |   ^^^^^^^^^^^^^^^\n  3 | }\n```\n\n일단 vite 라이브러리 모드를 사용하도록 하자.\n\n## 참고 자료\n- https://github.com/egoist/tsup/discussions/870\n- https://github.com/shaka-project/shaka-player\n- https://github.com/shaka-project/shaka-player/issues/1030#issuecomment-881283681\n\n"},{"fields":{"slug":"/programming/tdd/","title":"TDD"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: TDD\ntags:\n  - 테스트코드\n---\n\n## 프로그래밍 순서\n1. 실패하는 테스트 작성 = Red\n2. 빨리 테스트를 통과하게끔 구성 = Green\n3. 생겨난 중복 제거 = Refactoring\n"},{"fields":{"slug":"/programming/tree-shaking-versus-dead-code-elimination/","title":"Tree Shaking과 Dead Code Elimination"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Tree Shaking과 Dead Code Elimination\ntags:\n- javascript\n---\n\n## Dead Code Elimination  \nDead Code Elimination 은 컴파일러가 프로그램 결과에 영향을 미치지 않는 코드를 제거하기 위한 컴파일러 최적화\n\n각각의 언어마다 지원\n\n## Tree Shaking\n> tree shaking is a dead code elimination technique that is applied when optimizing code. - wikipedia  \n\n진입점에서 시작하여 실행하여 사용하지 않는 코드를 제거하는 방식\n\n### ESM 모듈 시스템\nCommonJS 모듈 방식에서 ESM 모듈 방식으로 바뀌면서, 모듈 로딩을 정적으로 구문 분석이 가능해짐  \n그에 따라 전체 종속성 트리를 추론할 수 있게 됨\n\n## 둘의 차이점  \n> Bad analogy time: imagine that you made cakes by throwing whole eggs into the mixing bowl and smashing them up, instead of cracking them open and pouring the contents out. Once the cake comes out of the oven, you remove the fragments of eggshell, except that’s quite tricky so most of the eggshell gets left in there.   \n> \n> You’d probably eat less cake, for one thing.\n> \n> That’s what dead code elimination consists of — taking the finished product, and imperfectly removing bits you don’t want. Tree-shaking, on the other hand, asks the opposite question: given that I want to make a cake, which bits of what ingredients do I need to include in the mixing bowl?\n> \n> https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80\n\n모든 재료를 넣고 거기서 필요한 것을 골라내는 것보다, 애초에 필요한 것들을 골라서 넣는 것이 더 효율적이다.\n\n![출처: sosolog](../attachments/dead-code-elimination-vs-tree-shaking.png)\n\n## 부록) Next.js Modularize Imports \n\n많은 패키지들이 \"barrel file\" 을 패키지에 많이 사용한다.\n\n```typescript jsx\nimport { Row, Grid as MyGrid } from 'react-bootstrap'\nimport { merge } from 'lodash'\n```\n하지만 모듈에 따라 사용하지 않는 모듈이 import 되는 케이스들이 있다.\n그래서 ESM 기반으로 번들링되어 있는 모듈을 사용하여 Tree Shaking 이 되도록 하거나, 아래 코드처럼 사용하는 패키지를 특정해서 가져오는 방법을 사용하기도 한다.\n```typescript jsx\nimport Row from 'react-bootstrap/Row'\nimport MyGrid from 'react-bootstrap/Grid'\nimport merge from 'lodash/merge'\n```\nNext.js 가 13 버젼으로 업데이트되면서, [modularizeImports](https://nextjs.org/docs/advanced-features/compiler#modularize-imports) 기능이 stable 되었다.\n\n\n기존 [babel-plugin-transform-imports](https://www.npmjs.com/package/babel-plugin-transform-imports) 와 같은 기능을 제공하는데, \n해당 기능은 정의된 패턴을 기반으로 import 구문을 변경하는 기능을 제공한다.\n\n**사용방법**  \n```typescript jsx\nmodule.exports = {\n  modularizeImports: {\n    'lodash': {\n      transform: 'lodash/{{member}}',\n    },\n  },\n};\n\n\n// Before\nimport { merge } from 'lodash'\n\n// After \nimport merge from 'lodash/merge'\n```\n\n## 참고 자료\n- [Tree-shaking versus dead code elimination](https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80)\n- [Tree Shaking과 Module System](https://so-so.dev/web/tree-shaking-module-system/)\n- [https://nextjs.org/docs/advanced-features/compiler#modularize-imports](https://nextjs.org/docs/advanced-features/compiler#modularize-imports)\n- [https://nextjs.org/blog/next-13-1#import-resolution-for-smaller-bundles](https://nextjs.org/blog/next-13-1#import-resolution-for-smaller-bundles)\n\n\n"},{"fields":{"slug":"/programming/tree-shaking/","title":"Tree Shaking"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Tree Shaking\ntags:\n- Web\n---\n\n## 정의\n\n사용되는 않는 코드를 제거하는 방식\n"},{"fields":{"slug":"/programming/typescript/","title":"Typescript"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Typescript\ntags:\n  - Typescript\n---\n\n## ReturnType 으로 타입 좁히기\n\n### 현상\n\n```tsx\nconst test = {\n  aaaa: {\n    getValue: () => 'hello',\n  },\n  bbbb: {\n    getValue: () => 123,\n  },\n};\n\nconst foo = (testKey: keyof typeof test) => {\n  const a = test[testKey].getValue(); // a type is number | string\n\n  return a;\n};\n\nconst b = foo('aaaa'); // b type is number | string   --> hope, string\nconst c = foo('bbbb'); // c type is number | string   --> hope, number\n```\n\nb 의 타입은 `string`, c 의 타입은 `number` 로 추론하는 것을 기대했지만, 객체 프로퍼티에서 동일한 이름을 가진 함수의 리턴 타입이 다를 때 해당 함수의 key 값을 명시해줘도 타입을 추론하지 못하는 현상이다.\n\n### 원인\n\n타입 스크립트에서 `testKey` 로 접근한 `getValue` 함수의 리턴 타입을 추론할 수 없기 때문인데 `ReturnType` 을 이용해 해결하였다.\n\n### 해결\n\n```tsx\nconst test = {\n  aaaa: {\n    getValue: () => 'hello',\n  },\n  bbbb: {\n    getValue: () => 123,\n  },\n  cccc: {\n    getValue: () => true,\n  },\n  dddd: {\n    getValue: () => [] as number[],\n  },\n};\n\nconst foo = <T extends keyof typeof test>(testKey: T): ReturnType<typeof test[T]['getValue']> => {\n  return test[testKey].getValue() as any;\n};\n\nconst a = foo('aaaa'); // string\nconst b = foo('bbbb'); // number\nconst c = foo('cccc'); // boolean\nconst d = foo('dddd'); // number[]\n```\n\n\n\n\n"},{"fields":{"slug":"/programming/vite-라이브러리-모드에서-invalid-hook-call/","title":"vite 라이브러리 모드에서 Invalid hook call 오류 발생"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: vite 라이브러리 모드에서 Invalid hook call 오류 발생\ntags:\n- vite\n- 트러블슈팅\n---\n\n## 문제 상황\nvite library mode 로 빌드를 하던중 해당 패키지를 가져다가 사용하는 곳에서 invalid hook call 오류가 발생했다. \n\n```\nreact.development.js:209 Warning: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\nprintWarning @ react.development.js:209\nreact.development.js:1630\n\nUncaught TypeError: Cannot read properties of null (reading 'useRef')\n```\n\n## 해결 과정\n해당 라이브러리 모드에서 사용하는 측에서 react, react-dom 는 이미 설치되어서 사용되기 때문에 peerDependencies 로 설정해주었다. \n\n```json\n{\n  \"peerDependencies\": {\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\"\n  }\n}\n```\n\n하지만 vite.config.ts 의 `rollupOptions.external` 에 해당 라이브러리를 추가해주지 않아서 react, react-dom 이 번들에 포함되었다. \n\n## 해결 방법\n\n`rollupOptions.external` 에 react, react-dom 패키지를 명시해주어 번들에서 제외시켰다.\n\n```typescript\n//vite.config.ts\n{\n  build: {\n    // …\n    rollupOptions: {\n      external: ['react', 'react-dom']\n    }\n  }\n}\n```\n\n## 참고 자료\n\n- https://dev.to/receter/how-to-create-a-react-component-library-using-vites-library-mode-4lma\n- https://ko.vitejs.dev/guide/build.html#library-mode\n- https://github.com/vitejs/vite/issues/11069\n"},{"fields":{"slug":"/resume/resume/","title":"조성륜 이력서"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 조성륜 이력서\ntags:\n  - 이력서\n---\n\n## 자기소개\n  \n  안녕하세요. 저는 3년차(만 4년) 프론트엔드 개발자 **조성륜(PAPICO)** 입니다.\n- 이메일: ocipap0531@gmail.com\n- Github: https://github.com/ocipap\n- 위키: https://ocipap.github.io/\n- 블로그 (위키로 이전): https://pa-pico.tistory.com/\n## Work Experience.\n### INFLAB (2019.08. ~ 현재)\n#### 인프런 학습페이지 개선\n현재의 인프런 학습페이지를 React 기반의 모던 스펙으로 마이그레이션하는 개선을 진행하였습니다.  \n\n**홈페이지 주소**\nhttps://www.inflearn.com/\n\n\n**사용 기술**\nShaka player, React, Typescript, redux, react-query, react-hook-form, react-testing-library, vite  \n\n**주요 내용**\n- react-hook-form 의 Controller 컴포넌트를 사용하여, 기존 시스템 컴포넌트를 hook form 컴포넌트로 다룰 수 있게 해줌\n- react-query 를 통해 api 통신 상태를 관리\n- Shaka player 을 통해, 동영상 콘텐츠 제공\n\t- 커스텀 컨트롤러 추가 (모바일 컴포넌트)\n#### 랠릿  \nIT 채용 플랫폼 랠릿 서비스의 어드민 페이지를 개발하였습니다.  \n\n**홈페이지 주소**  \nhttps://www.rallit.com/en      \n\n**사용 기술**\nReact, Typescript, redux, redux-toolkit, redux-saga, Ant design  \n\n**주요 내용**\n- redux-saga 와 redux-toolkit 의 구조를 고도화하여, 최대한 코드의 중복을 제거\n- 비동기 로직을 상태로서 다루어, 컴포넌트에서 상태의 변화 기반으로 로직을 실행하는 선언적프로그래밍 도입\n- 비즈니스 서비스 (B2B)와 사용자 서비스 (B2C) 에서 공통으로 사용하는 로직을 모노레포로 구성하여 재활용\n#### SEO 최적화\n<strong style=\"color: skyblue;\">As is</strong>  \n페이지의 title 과 description 이 규칙이 없이 무분별하게 삽입되는 것을 개선하기 위해,  \nhtml head 태그를 만들어내는 로직을 고도화 시켜, 페이지의 title, description 에 규칙을 부여했습니다.  \n추가적으로 유용한 상품 관련 meta 데이터 추가와 페이지 url 별로 사이트맵을 생성하는 로직을 추가하였습니다.\n\n<strong style=\"color: skyblue;\">To Be</strong>  \n그 결과 `[특정 기술] + 온라인 강의` or `[특정 기술] + 강의` 라는 검색어를 구글에 검색했을때 광고를 제외한 검색 결과에서 최상단에 위치할 수 있었습니다.\n#### Google Tag Manager 도입\n<strong style=\"color: skyblue;\">As is</strong>  \n프론트엔드 서비스 로직에 광고 스크립트가 **무분별하게 삽입**되는 것을 개선하기 위해,  \n각각의 퍼널에 맞춤이벤트를 설정하고, **모든 광고 스크립트를 Google Tag Manager 로 이전**했습니다.  \n퍼널 별로 유의미한 데이터를 함께 보내, 광고 스크립트에서 변수로써 활욜할 수 있도록 개선했습니다.  \n\n<strong style=\"color: skyblue;\">To Be</strong>  \n**그 결과 광고스크립트 삽입 요청이 서비스 코드의 배포없이 진행될 수 있었습니다.**\n#### A/B 테스트 도입\nHackle 이라고 하는 A/B 테스트 플랫폼 을 도입하여, **A/B 테스트가 가능한 운영 환경**을 구성하였습니다.  \n위 작업을 통해 **A/B 테스트의 기본 원리** 를 알게되었고,  \n**데이터를 기반으로 하는 개선 작업**을 진행할 수 있게 되어, 의사 선택하는 것에 도움이 되었습니다.\n#### 인프런 기능 고도화\n과거 워드프레스로 되어 있는 기능을 자체 코드로 마이그레이션 및 고도화를 진행하였습니다.    \n사용한 기술은 Node.js, Vanilla javascript 를 베이스로 Server Side Rendering 으로 개발하였습니다.    \n현재의 인프런이라는 서비스를 존재하게 해주는 프로젝트로 그때 그 당시의 익숙한 기술 선택하여 빠르게 개발하였습니다.\n- 쿠폰: 인프런 사이트 내부에서 사용되는 쿠폰 및 수강코드 기능 추가\n- 비즈니스 서비스: B2B 서비스 기능 추가\n- 학습페이지: 수업 영상을 시청하는 학습페이지 기능 개선\n- 사이트 내 알림: 사이트 내 활동에 관한 알림 기능 추가\n- 수강 노트: 영상 학습 중간 메모를 추가하는 기능 추가\n- 멘토링 서비스: 멘토링 중개 기능 추가\n- 강의 소개 페이지: 강의 상품을 소개하는 페이지 기능 및 UX 개선\n## Other Experiences.\n### 네이버커넥트재단 부스트캠프 웹 6기 리뷰어\n부스트 캠프 웹, 모바일 6기 리뷰어로 참여하여, 팀별 코드 리뷰 및 가이드 진행\n\n**홈페이지**  \nhttps://boostcamp.connect.or.kr/\n### 코드스쿼드 멤버스 프로젝트 리뷰어\n코드스쿼드 멤버스 프로젝트 리뷰어로 참여하여, 팀별 코드 리뷰 및 가이드 진행\n\n**홈페이지**  \nhttps://codesquad.kr/\n### 인프런 상시 멘토링 진행\n인프런 페이지의 이력서 및 커리어 멘토링을 상시 진행하였습니다.  \n현재 총 19건의 멘토링을 진행하였습니다.\n\n### 설리번 프로젝트\n고등학생들을 대상으로 한 웹 프론트엔드 멘토링을 진행하였습니다.\n\n**홈페이지**  \nhttps://slvn.page.link/-LT14Za2B638t9DAv0R-\n\n### 코드스쿼드 미니 컨퍼런스 발표 - 개발만 잘하면 되는 줄 알았어요.\n\"개발만 잘하면 되는 줄 알았어요.\" 라는 주제로 개발자가 개발 외적으로 작용하는 일을 되게하는 방법에 대해 발표하였습니다.  \n\n**관련 내용**  \n  [[개발만 잘하면 되는 줄 알았어요.]] ]\n\n### Inflab 심야 FE 발표 - 랠릿은 어떻게 만들어졌을까?  \n인프랩에서 주최한 심야 FE 컨퍼런스에서 \"랠릿은 어떻게 만들어졌을까?\" 라는 주제로 랠릿을 개발하면서 발생했던 문제점과, 해결 방법, 그리고 방지책을 이야기했습니다.\n"},{"fields":{"slug":"/programming/웹성능최적화/","title":"웹 성능 최적화"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 웹 성능 최적화\ntags:\n  - 웹 성능 최적화\n---\n\n## 웹 성능을 결정하는 요소\n\n**로딩 성능**  \n각 자원을 불러오는 성능\n\n**렌더링 성능**  \n불러온 자원을 화면에 보여주는 성능\n\n## 이미지 CDN을 활용한 로딩 최적화\n\n표현하고자 하는 영역의 크기에 맞춰 이미지의 크기를 로드하면 이미지 자원을 로드하는데 드는 비용을 줄일 수 있다.  \n보통 표현하는 영역의 2배 정도의 크기를 불러오면 깨짐 없이 표현할 수 있다.\n\n## 이미지 압축을 활용한 로딩 최적화\n\n이미지를 압축하면 이미지 자원을 로드하는데 드는 비용을 줄일 수 있다.\npng < jpg < webp 순으로 압축률이 높다.\n\nhttps://squoosh.app/\n\n위 사이트에서 이미지를 특정 확장자로 변경하면서 압축할 수 있다. 이때 화면에 노출되는 영역의 크기에 따라 이미지를 resize 해서 압축률을 높일 수 있다.\n\n다만 webp의 경우 지원하지 않는 브라우져가 있기 때문에, fallback으로 jpg를 사용하는 것이 좋다.\n\n```html\n<picture>\n  <source srcset=\"{props.webp}\" type=\"image/webp\" />\n  // webp 를 지원하는 브라우져에서만 사용 <img src=\"{props.image}\" /> // webp\n  로딩에 실패했을 경우 jpg 를 사용\n</picture>\n```\n\n## 동영상 압축을 활용한 로딩 최적화\n\n동영상 또한 이미지처럼 압축을 통해 로딩 성능을 최적화할 수 있다.  \n다만 동영상의 경우 화질이 떨어지면 사용자 경험에 큰 영향을 미칠 수 있기 때문에, 서비스에 특성에 맞추어 적절하게 진행하면 좋다.\n\n이미지와 마찬가지로 webm 이라는 압축률이 좋은 확장자가 있지만, 지원하지 않는 브라우져가 있기 때문에 fallback을 고려해야한다.\n\n```html\n<video controls width=\"250\">\n  <source src=\"/media/cc0-videos/flower.webm\" type=\"video/webm\" />\n  <source src=\"/media/cc0-videos/flower.mp4\" type=\"video/mp4\" />\n</video>\n```\n\n## Bottleneck 코드 최적화\n\nLightHouse 의 Diagnostics 와, Performance 탭을 통해서 병목이 발생하는 코드를 알 수 있다.\n\n리액트의 경우 Performance 탭에서 컴포넌트 계층별로 렌더링 시간 등을 확인할 수 있다.\n\n![](../attachments/.웹성능최적화_images/9275fc6c.png)\n![](../attachments/.웹성능최적화_images/bf6c92cb.png)\n\n위 사진에서는 Article 컴포넌트의 `removeSpecialCharactor` 함수가 오랜 시간 실행되고 있는 것을 확인할 수 있다.  \n그리고 함수가 실행되면서 중간중간 끊겨있는 것을 확인할 수 있는데, 이는 브라우져에서 함수를 실행하는 중간중간 메모리를 정리했기 때문이다. 하단의 minor GC를 통해 단서를 얻을 수 있다.\n\n## 번들 파일 분석 (bundle-analyzer)\n\nbundle-analyzer를 통해 번들된 결과물을 분석할 수 있다.\n\n![](../attachments/.웹성능최적화_images/34a52c50.png)\n\n만약 번들된 결과물에서 devDependencies가 포함되어 있거나, 특정 페이지에서만 필요한 라이브러리가 번들에 크게 포함되고 있다면 Code Splitting을 통해 빌드 파일을 분리할 수 있다.\n\n## 코드 스플리팅 (Code Splitting)\n\n코드를 분할하는 것 -> 불필요한 코드 또는 중복되는 코드가 없이 적절한 크기의 코드가 적절한 타이밍에 로드될 수 있도록 하는 것\n\n**Route-based code splitting**  \nhttps://reactjs.org/docs/code-splitting.html#route-based-code-splitting\n\n페이지 별로 `React.lazy`를 걸어서 특정 경로에 필요한 번들 파일만 로드할 수 있게 하는 것 또한 방법이다.  \n`React.lazy` 는 반드시 `Suspense`와 같이 사용해야 한다.\n\n**Component-based code splitting**  \n모달과 같이 초기에 화면을 그리는데 필요가 없는 컴포넌트의 경우에도 코드 스플리팅을 통해 번들 파일을 분리하는 것이 가능하다.\n\n## 컴포넌트 Preloading\n\nLazy Loading 의 단점 중에 하나로 분리된 번들 파일이 필요한 시점에 load 되고, 실행하는데 시간이 걸린다는 것이다.  \n따라서 이를 해결하기 위해 미리 파일을 로드해 두고 필요한 시점에 실행할 수 있도록 하는 방법이 Preloading 이다.\n\n**컴포넌트 Preload 타이밍**  \n모달을 예로 들면\n\n1. 모달을 여는 버튼 위에 마우스를 올려놨을 때\n2. 최초 페이지 로드가 되고 모든 컴포넌트의 마운트가 끝났을 때\n\n1번의 경우에 마우스에 올리고, 바로 클릭을 할 수도 있기 때문에 modal 파일이 크다면 크게 효과가 없을 수 있다. 따라서 useEffect 훅을 사용해서 모든 컴포넌트가 마운트가 끝난 이후에 modal 관련 번들 파일을 로드하는 것이 효과적이다.\n\n```tsx\nfunction lazyWithPreload(importFunction) {\n  const Component = React.lazy(importFunction);\n  Component.preload = importFunction;\n  return Component;\n}\n\nconst LazyImageModal = lazyWithPreload(() => import(\"./components/ImageModal\"));\n\n// ...\nuseEffect(() => {\n  LazyImageModal.preload();\n}, []);\n```\n\n## 이미지 Preloading\n\nImage 오브젝트를 사용해서 필요한 이미지를 미리 로드할 수 있다.  \n단 Image 오브젝트의 src를 이용한 방법은 실행할 때마다 이미지 네트워크 요청을 보내기 때문에 대상 이미지에 cache 설정이 필요하다.\n미리 이미지 로드 -> 필요한 시점에 이미지 로드 (이미 캐싱 된 이미지를 반환)\n\n## 이미지 지연 Loading\n\n이미지가 화면에 보이는 시점에 이미지를 로드하여 아직 화면에 노출되지 않은 이미지에 대한 로딩 최적화 기법\n\n**Intersection Observer**\n화면에 보이는 요소를 관찰하여 특정 시점에 콜백 함수를 실행하는 API\n\n- Observer 객체가 생성되었을 때\n- 요소가 화면에 노출되었을 때\n- 요소가 화면에서 노출되었다가 사라졌을 때\n\n```tsx\nimport React, { useEffect, useRef } from \"react\";\n\nfunction Card(props) {\n  const imgRef = useRef(null);\n\n  useEffect(() => {\n    const options = {};\n    const callback = (entries, observer) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          console.log(\"is intersecting\", entry.target.dataset.src);\n          entry.target.src = entry.target.dataset.src;\n          observer.unobserve(entry.target);\n        }\n      });\n    };\n    const observer = new IntersectionObserver(callback, options);\n\n    observer.observe(imgRef.current);\n  }, []);\n\n  return (\n    <div className=\"Card text-center\">\n      <img data-src={props.image} ref={imgRef} />\n      <div className=\"p-5 font-semibold text-gray-700 text-xl md:text-lg lg:text-xl keep-all\">\n        {props.children}\n      </div>\n    </div>\n  );\n}\n\nexport default Card;\n```\n\n- callback 함수의 인자로는 observe 하고 있는 요소 배열과, observer 객체가 전달된다.\n- entries 는 observe 하고 있는 요소 배열이기 때문에 forEach 를 통해 순회하면서 각각의 entry 에 접근한다.\n- `entry.isIntersecting`를 통해 해당 요소가 화면에 노출되었는지를 확인할 수 있다.\n- dataset 객체를 이용해서 img의 src를 원하는 시점에 변경할 수 있도로 임시로 이미지 소스의 주소를 담아두었다.\n- `entry.isIntersecting`가 참이 되는 시점에 dataset 객체에 임시로 넣어둔 이미지 소스를 `img.src` 에 넣어준다.\n- 그리고 observer.unobserve를 통해 해당 요소를 관찰 대상에서 제외한다. (이미지가 화면에 노출되었기 때문에 더 이상 관찰할 필요가 없다.)\n\n## 텍스트 압축 (Text Compression)\n\n텍스트 압축을 통해 전송되는 데이터의 양을 줄일 수 있다. (로딩 성능 최적화)\n\nResponse Header에서 `Content-Encoding: gzip` 을 통해 압축된 데이터를 전송할 수 있다.  \n이때 고려해야 할 점은 결국 압축한 파일을 프론트엔드에서 압축을 해제해야하기 때문에 이 또한 비용이다.  \n따라서 무분별하게 압축하는 것보다, 2KB 이상 되는 파일을 압축하는 것이 효과적이다.\n\n## 애니메이션 최적화 (Animation)\n\n**쟁크현상**  \n60fps를 유지하지 못할 때 발생. 애니메이션이 버벅대는 현상\n\n**브라우져 렌더링 과정**\n![](../attachments/.웹성능최적화_images/92947bae.png)\n\nLayout: 위치나 크기를 계산  \nPaint: 색을 채워 넣는 과정  \nComposite: 계층을 합치는 과정\n\n![](../attachments/.웹성능최적화_images/d080b23c.png)\n위에 사진처럼 1번에 점선에는 이미 사용자에게 프레임을 노출되어야하는 시점인데 아직 2번과 같이 composite 과정이 끝나지 않았기 때문에 애니메이션이 버벅댐\n\n따라서 애니메이션 최적화는 Reflow, Repaint 과정을 줄이는데 있음\n\n**Reflow** : width, height (위치나 크기) 변경 -> Critical Rendering Path 전체 실행  \n**Repaint** : color (색) 변경 -> Layout 과정 생략\n\nGPU가 관여할 수 있는 속성으로 변경해 Layout 과 Paint 과정을 생략할 수 있다. (transform, opacity)\n\n## 폰트 최적화 (폰트 적용 시점 컨트롤하기)\n\n**폰트 디스플레이 방식**\n\n- FOUT (Flash of Unstyled Text): 기본 텍스트가 노출되다가 이후 폰트가 적용되는 방법\n- FOIT (Flash of Invisible Text): 폰트가 로드될 때까지 텍스트가 노출되지 않다가 폰트가 로드된 이후에 폰트가 적용되는 방법\n\n각각의 브라우져마다 font-display 방식이 다름\n\n**font-display**\n\n> The font-display descriptor for the @font-face at-rule determines how a font face is displayed based on whether and when it is downloaded and ready to use.\n\n```\nfont-display: auto; // 각각의 브라우져에 설정된 기본값 따름\nfont-display: block; // FOIT 방식\nfont-display: swap; // FOUT 방식\nfont-display: fallback; // FOIT 방식, timeout 이후에도 폰트 로드에 실패한다면 기본 폰트를 유지하고, 이후 로드된 폰트를 캐시\nfont-display: optional; // FOIT 방식, fallback과 유사하지만, 네트워크 상황에 따라 브라우져가 폰트 다운로드 여부를 결정\n```\n\n서비스에 폰트가 노출되는 특성에 따라 적절한 font-display 방식을 선택  \n폰트가 노출될 때 애니메이션을 추가 (체감 성능 개선)\n\n**Font Face Observer**  \n폰트가 로드되었는지를 확인할 수 있는 npm 라이브러리  \nhttps://fontfaceobserver.com/\n\n```tsx\nconst [isFontLoaded, setIsFontLoaded] = useState(false);\n\nconst font = new FontFaceObserver(\"FONT_NAME\");\n\nuseEffect(() => {\n  font.load().then(function () {\n    console.log(\"FONT_NAME has loaded\");\n    setIsFontLoaded(true);\n  });\n}, []);\n```\n\n## 폰트 최적화 (사이즈 줄이기)\n\n**웹폰트 포맷 사용**  \nttf -> woff -> woff2 순으로 압축률이 높다.\n\n[폰트압축 및 변환 사이트](https://transfonter.org/)\n\n```css\n@font-face {\n  font-family: BMYEONSUNG;\n  src: url(\"./assets/fonts/BMYEONSUNG.woff2\") format(\"woff2\"), url(\"./assets/fonts/BMYEONSUNG.woff\")\n      format(\"woff\"), url(\"./assets/fonts/BMYEONSUNG.ttf\") format(\"truetype\");\n  font-display: block;\n}\n```\n\n**local 폰트 사용**  \n사용자의 PC에 이미 폰트가 다운로드되어 있다면 폰트 다운로드 없이 해당 폰트를 사용할 수 있다.\n\n`local('FONT_NAME')` 이라는 키워드로 명시\n\n```css\n@font-face {\n  font-family: BMYEONSUNG;\n  src: local(\"BMYEONSUNG\"),\n    url(\"./assets/fonts/BMYEONSUNG.woff2\") format(\"woff2\"), url(\"./assets/fonts/BMYEONSUNG.woff\")\n      format(\"woff\"), url(\"./assets/fonts/BMYEONSUNG.ttf\") format(\"truetype\");\n  font-display: block;\n}\n```\n\n**Subset 사용**  \n많은 폰트 중에서 서비스에 사용하는 만큼 글자를 지정해서 불러오는 방식, 폰트 변환 시 특정 문자를 지정해서 적용할 수 있다.  \n지정되지 않은 텍스트의 경우 화면에서 폰트가 적용되어 있지 않은 채로 노출된다.  \nSubset의 경우 화면에 지정한 폰트가 없더라도 폰트 자원을 받아오기 때문에, Unicode Range를 사용한다.\n\n**Unicode Range 사용**  \n유니코드 범위를 지정해 대상 글자만 폰트를 적용하고, 만약에 해당 글자가 존재하지 않으면 폰트 자원을 로딩하지 않는다.\n\n**data-uri로 변환**  \n페이지 자체에 폰트 데이터를 그대로 넣어서 파일을 로딩할 때 폰트 자원 관련 네트워크 요청을 보내지 않게 하는 방법도 있다.\n\n## 폰트 프리로드 (Preload)\n\n보통의 경우 CSS 파일을 읽은 후 해당 폰트를 사용한다고 판단되면, 그 시점에 폰트 자원을 호출한다.  \n폰트 Preload 란 미리 해당 폰트가 웹사이트에서 사용된다고 명시하여, 먼저 로드할 수 있도록 해준다.\n\n```html\n<link rel=\"preload\" href=\"주소\" as=\"font\" type=\"font/woff2\" crossorigin />\n```\n\n## 캐시 최적화\n\nlighthouse의 Diagnostics에 `Serve static assets with an efficient cache policy`  \n정적 자원에 효율적인 캐시를 적용함으로써 캐시 최적화를 할 수 있다.\n\n캐시는 데이터나 값을 미리 복사해놓는 임시 장소나 그러한 동작을 뜻한다.\n\n**브라우져 캐시 저장 장소**\n\n- `memory cache`: 메모리(RAM)에 자원을 저장하고 로드, 브라우져를 닫을 때까지 자원을 사용할 수 있다.\n- `disk cache`: 캐시된 자원을 디스크에 저장, 로드한다.\n\n**공유 캐시와 비공개 캐시**\n\n- `Shared cache`: 공유 캐시, CDN이나 Proxy처럼 원본 서버와 클라이언트 사이에 존재하는 캐시, 여러 사용자에서 재사용되므로 개인화된 콘텐츠에서는 사용되어서는 안된다.\n- `Private cache`: 클라이언트에 존재하는 캐시로, 로컬 캐시 혹은 브라우져 캐시라고 부른다. 단일 사용자를 위한 개인화된 콘텐츠를 저장하고 사용할 수 있다.\n\n**Cache-Control**  \nHTTP 헤더에 들어가는 값으로 만료나 방식으로 설정할 수 있다.\n\n- `Cache-control: public`\n  - 공유 캐시에 저장할 수 있음,\n  - 일반적으로 페이지가 인증 상태인 경우에는 권한 부여 헤더와 함께 요청을 보내기 때문에 기본적으로 공유 캐싱이 불가능하다. 이때 `public` 을 사용하면 해당 제한을 해제할 수 있다.\n  - 요청에 별도의 `Authorization` header가 없거나, `s-maxage` 혹은 `must-revalidate`를 사용하고 있다면 `public`을 사용할 필요가 없다.\n- `Cache-control: private`\n  - 응답을 비공개 캐시에만 저장할 수 있음\n- `Cache-control: no-cache`\n  - 캐시에 저장된 콘텐츠를 사용하기전에 원본 서버에 유효성 체크를 실행\n  - 캐시를 사용하지 않음 이라는 뜻이 아님\n- `Cache-control: no-store`\n  - 캐시를 사용하지 않음\n  - 모든 종류의 캐시가 해당 응답을 저장해서는 안 됨\n- `Cache-control: max-age=<seconds>`\n  - 응답이 생성된 후 지정한 초만큼 응답이 최신 상태로 유지됨을 나타낸다.\n  - 지정한 시간은 응답을 받은 후 경과 시간이 아닌, 원본 서버에서 응답이 생성된 후 경과한 시간을 의미함\n- `Cache-control: stale-while-revalidate=<seconds>`\n  - 캐시의 유효성을 재검증하는 동안 기존 오래된 응답을 재사용할 수 있음을 나타냄\n\n**Etag**  \nHTTP 응답 헤더로 특정 버젼의 자원을 식별하는 식별자\n\n## 불필요한 코드 제거\n\n개발자 도구 하단 탭의 Coverage에서 특정 자원이 해당 페이지에서 얼마만큼 사용되었는지에 대한 정보를 얻을 수 있다.\n![불필요한코드](../attachments/.웹성능최적화_images/image.png)\n\n**불필요한 css 코드 제거**\n\n[purge css](https://purgecss.com/)는 static한 파일을 읽어 사용하지 않는 CSS를 제거해준다.\n"},{"fields":{"slug":"/think/개발만 잘하면 되는 줄 알았어요/","title":"개발만 잘하면 되는 줄 알았어요"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 개발만 잘하면 되는 줄 알았어요\ntags:\n  - 발표\n  - 회고\n  - 생각정리\n---\n해당 글은 코드 스쿼드 미니 컨퍼런스 때 발표했던 \"개발만 잘하면 되는 줄 알았어요\" 발표의 생각 정리 글이다.\n\n나는 현재 스타트업에서 2년 조금 넘게 개발일을 하고 있는 주니어이다. 개발자가 3명일때 부터 합류해 지금은 20명 거의 가까이 되는 개발팀에서 일을 하고 있다. 사람이 늘어나면서 \"일을 되게하는 사람\"의 특징이 눈에 보이기 시작했는데, 주니어의 시각으로 한 번 씨부려보겠다.\n\n지극히 개인적인 이야기이다. 내가 앞으로 걸어가고 싶은 길이기도하니 내용 상 부적잘하다고 생각되는 부분이 있다면 피드백 부탁드립니다 ㅎ\n\n### 일정을 어떻게든 맞춘다.\n\nA는 일을 진행할때 **100%의 퀄리티**를 뽑아낸다. 다만 퀄리티를 뽑아내기 위해서 간혹 **기존 일정을 넘어서** 일을 진행하는 경우가 있다. B는 결과물 자체는 **80% 정도의 퀄리티**를 유지한다. 하지만 A와 다르게 정해진 **일정을 지키는 모습**을 보인다.\n\n이 두사람중에 일을 되게하는 사람은 **B** 이다.\n\n업무를 진행하다보면 나의 의욕과는 다르게 예상 밖에 일들이 많이 일어난다. 일을 시작하기 전에는 미쳐 생각하지 못한 일들로 인해 기존에 설정해두었던 일정이 어겨지는 일도 더러 발생한다. 그래서 항상 퀄리티를 더 가져갈까? 혹은 일단 돌아가는 형태로 만들까? 에 대한 고민을 하게 된다.\n\n이런 상황에서는 지금 진행하고 있는 업무를 적당히 끊어 마무리 짓고, 새로운 계획을 새우는 방법을 택하는 것이 좋다. 조금만 더 하면 마무리 될것 같은데 라는 생각으로 1주 2주가 계속 지나면, 해당 일정을 관리하고 있는 매니저도, 업무를 진행하고 있는 당사자도 지친다.\n\n당연히 이런 상황에서 적당히 마무리를 짓는 선택을 하면 기존에 계획했던 모습과는 못미치는 결과물이 나올 수 있다. 하지만 적당한 템포로 업무를 마무리하고 다시 계획을 세웠을 때 오히려 추진력있게 일들이 진행된다.\n\n개개인이 자신의 업무를 100% 마무리까지 끌고 갈 수 있는 힘을 기르는 훈련이 필요하다\n\n### 최선이 아니라 차선을 선택한다.\n\n업무를 진행하면서 여러가지 선택을 해야하는 상황이 온다. 그리고 그 여러가지 선택지들은 각각의 장단점들이 존재한다. 모두가 같은 것을 원하면 좋지만 사실 현실은 그렇지 않다. 어떤 사람 입장에서는 해당 방법이 정말 말이 안된다고 생각할 수도 있고, 또 어떤 사람은 자신이 제시한 방법의 자신의 투영하여 의견의 단점이 곧 자신을 블레임하는 것이라고 느낄 수도 있다. 사람이기 때문에 이런 현상은 당연하다고 생각한다. 하지만 이런 상황에서도 우리는 결정을 해야한다.\n\n이때 중요한것은 **현재 상황에 차선의 선택**이다. 단점이 존재하지 않는 의견은 없다. 단점이 없다면 애초에 이러한 선택을 할 상황이 만들어 지지 않는다. 누가 봐도 명확한 단점이 존재하는 의견이라도 현재 상황에서 얻게될 장점이 더 크다고 판단되면 그 선택을 해야한다. 그 선택을 이해해야만 한다.\n\n해당 단점에 대해 강하게 주장했던 사람은 해당 선택을 받아드리기 힘들 수도 있다. 그리고 또한 시간이 지난 뒤에 그때 드러났던 단점으로 인해서 위기가 생길 수 있다. 이 상황에서 일이 되지 않게 하는 사람들은 더러 자신이 과거에 주장했던 의견들을 들어내며 불평을 할 수 있다.\n\n나는 무시한다.(**이야기는 듣지만 크게 동조하지 않는다는 뜻**) 현재의 벌어질 일은 현재가 아니면 알 수 없다. 그럼에도 불구하고 우리는 차선을 선택한 것이고, 분명 그 선택으로 인해 얻은 것도 있을 것다. **중요한 것은 현재이다.**\n\n### 문제의 원인을 가장 먼저 환경, 동료, 회사, 시간에서 찾지 않는다.\n\n문제가 없이 진행되는 업무는 극히 드물다. 그 문제의 원인은 정말 다양한데, 개발을 진행하는 환경, 참여하는 구성원의 실수, 회사의 정책적인 이슈, 절대적인 업무의 시간 등 여러가지가 있다.\n\n여기서 중요한 것은 프로젝트가 진행되는 중에는 절대 자신이 아닌 다른 곳에서 원인을 찾지 않는 것이다.\n\n구성원 개개인은 사람이기 때문에, 업무에서 감정이 드러나기 마련이다. 따라서 프로젝트 진행중에는 각각의 구성원들의 감정을 상하는 일이 없이 진행되어야 한다.\n\n그렇다고 발생한 문제에 대해 언급하지 말라는 것은 아니다. 그 문제는 고쳐지지 않으면 이후에 진행하는 프로젝트에서도 동일하게 발생할 수 있다. 따라서 프로젝트가 마무리된 이후에 회고를 통해 각각의 문제에 대한 원인을 같이 논의하고, 그 문제가 다시 재발하지 않기위해 할 수 있는 노력이 무엇인지 찾아가야한다.\n\n### 능동적으로 업무를 수행한다.\n\n업무를 진행하다보면 다른 구성원의 도움이 필요한 경우가 많다. 그렇기에 업무를 해당 담당자에게 맡긴 후 업무를 진행하는 경우가 있다. 이러한 업무 방식의 단점은 업무의 메인 담당자의 부재로 이루어 진다. 담당자가 없는 업무는 그 일이 언제 마무리될지, 어떻게 마무리가 되고 있는지에 대한 것을 알기 어려워진다.\n\n여기서 중요한 것은 자신에게 발생한 업무를 마무리까지 끌고가는 힘이다. 다른 구성원의 도움이 필요하면 해당 구성원이 업무를 처리하기에 소요되는 시간 및 일정, 업무가 딜레이 되고 있다면 그 원인이 무엇인지 등등 디텍팅해야 그 업무는 수월하게 마무리가 될 수 있다.\n\n개발자라는 직업으로 업무를 진행하다보니, 개발 이외에 커뮤니케이션과 인간 관계 부분에서의 성장도 중요하다는 것을 느끼고 있다. 그 성장을 멈추지 않기 위해 나는 나 스스로 경계하고 회고하며 앞으로 나아갈 것이다. 아마 주니어의 시각으로 보았을 때와 성장한 이후 미드레벨로 보았을때의 생각이 다를 수도 있다. 그 내용은 이후 미드레벨이 되었을 때 위 내용과 비교하며 이야기하겠다.\n\n마지막으로 좋은 발표 기회를 만들어 주신 JK 께 감사 인사를 드린다. 감사합니다! ㅎ"},{"fields":{"slug":"/tips/github-actions-workflow-dispatch/","title":"github actions 수동으로 트리거하기"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: github actions 수동으로 트리거하기\ntags:\n  - tip\n  - github actions\n---\n\n소프트웨어 개발과정에서 GitHub Actions를 활용하면 손쉽게 지속적 통합과 배포를 자동화할 수 있다. 일반적으로는 코드 저장소에 변경사항이 있을 때마다 자동으로 작업이 실행되지만, 때로는 수동으로 작업을 트리거하고 싶을 때도 있다. \n\n## `workflow_dispatch`\n\nGitHub Actions에서는 `workflow_dispatch` 이벤트를 통해 수동으로 작업을 트리거할 수 있다. 또한 `inputs` 를 통해 작업을 트리거할 때 추가적인 정보를 입력받을 수 있다.\n\n```yaml\nname: depoly\n\non:\n  workflow_dispatch:\n    inputs:\n      environment:\n        description: '배포할 환경을 선택하세요'\n        required: true\n        default: 'production'\n```\n\n![](../attachments/.github-actions-workflow-dispatch_images/b6471f82.png)\n\n## github cli 를 통해서 수동으로 작업 트리거하기\n`workflow_dispatch` 설정 시, github cli ([gh](https://cli.github.com/)) 로도 수동으로 작업을 트리거할 수 있다.\n\n```bash\ngh workflow run depoly --ref main -F environment=production\n```\n\n\n## 참고 자료\n- https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch\n- https://docs.github.com/ko/actions/using-workflows/manually-running-a-workflow?tool=cli\n\n\n"},{"fields":{"slug":"/tips/iterm2-to-webstorm/","title":"Iterm2 에서 cmd + click 으로 Webstorm 코드 라인으로 이동하기"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Iterm2 에서 cmd + click 으로 Webstorm 코드 라인으로 이동하기\ntags:\n  - tip\n---\n\nIterm 으로 build 명령을 실행하거나, 커밋을 하는 중간에 컴파일 에러가 발생하면 문제가 일어난 파일의 라인 수가 링크로 제공된다.\n\n```\nError: ENOENT: no such file or directory,\n    at Object.statSync (node:fs:1583:3)\n    at Object.statSync (/Users/papico/~~~/graceful-fs/polyfills.js:319:16)\n    at Object.publish (/Users/papico/~~~/gh-pages/lib/index.js:90:13)\n    at /Users/papico/~~~/gh-pages/bin/gh-pages.js:12:13\n    at new Promise (<anonymous>)\n```\n\n기본적으로 해당 경로를 command + click 시에 default application 으로 열리는데, 아래 설정 시 Webstorm 에서 해당 파일을 열 수 있다. \n\n## 설정\n\n[Profiles] > [Advanced] > [Semantic History] > [Run command...] 옵션 선택 후 아래 명령어 입력\n\n```\nwebStorm --line \\2 --column \\3 \\1\n```\n\n![iterm 설정창](../attachments/.iterm2-to-webstorm_images/fa4b7d95.png)\n\n\n## 참고 자료\n- https://www.jetbrains.com/help/webstorm/opening-files-from-command-line.html\n- https://r0k.wiki/ 주인장의 팁\n\n\n"},{"fields":{"slug":"/tips/jira/","title":"Jira"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Jira\ntags:\n  - 업무효율\n---\n\n## 종료한 스프린트 되돌리기\n잘못해서 종료시킨 스프린트를 되돌리는 방법은\n\n지라 프로젝트 > 보고서 > 번업 차트 > 메뉴 > 스프린트 다시시작 (종료했을 때만 활성화 됨) > 되돌릴 스프린트 선택\n\n![종료한 스프린트 되돌리기](../attachments/jira-2022-04-24-02-26-47.png)\n\n## Git repo 에 관련 코드 조각 검색하기\n\n[https://grep.app](https://grep.app)\n\n해당 웹사이트에서 내가 작성한 코드의 방식이 맞는지 대략적으로 확인할 수 있다.\n\n"},{"fields":{"slug":"/tips/raycast/","title":"Raycast"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Raycast\ntags:\n  - Raycast\n---\n\n최근 Alfred 와 Jira 를 연동해보려다가 실패를 해서 이것저것 찾아보던 중 Raycast 라는 Tool 을 알게되었다.  \n\n[설치 링크](https://www.raycast.com)\n\n자주 사용하거나 유용한 익스텐션을 적어보겠다.\n\n## Quicklinks\n\nAlfred 에서 자주 사용하던 기능인데, alias 와 query 를 기반으로 등록해두면 좀 더 쉽게 원하는 페이지로 이동할 수 있다.  \n\n|              | alias  | link                                                 |\n|--------------|--------|------------------------------------------------------|\n| Jira board   | `jb`   | `https://xxx.atlassian.net/browse/{Query}`           |\n| Font Awesome | `fa`   | `https://fontawesome.com/search?q={Query}`           |\n| Confluence   | `wiki` | `https://xxx.atlassian.net/wiki/search?text={Query}` |\n| Papago       | `pa`   | `https://papago.naver.com/?sk=auto&st={Query}`       |\n\n\n## File Search\n\n현재 내 기기안에 있는 파일을 Finder 보다 빠르게 찾아준다. (기본 기능)  \n자주 사용하는 기능이라 Alias 를 `[` 로 등록해두었다.\n\n![File Search](../attachments/raycast-2022-08-16-13-32-33.png)\n\n## Clipboard History \n\n붙여넣기 히스토리를 관리할 수 있다. (기본 기능)  \n자주 사용하는 기능이라 Hotkey 로 `cmd + shift + v` 로 등록해두었다.\n\n`Enter` 를 통해 바로 붙여넣기도 가능하고, `cmd + Enter` 를 통해 해당 텍스트를 다시 복사도 가능하다.  \n\n![Clipboard History](../attachments/raycast-2022-08-16-13-31-55.png)\n\n## Github\n\n[다운로드 링크](https://www.raycast.com/raycast/github)\n\nGithub 에서 제공하는 기능을 편하게 사용할 수 있도록 해준다.  \n주로 global repo 검색을 많이 사용한다.\n\n내가 관리하는 git repository 를 찾는 기능은 다른 익스텐션을 관리하는 것이 편한 것 같아 사용하지 않았다.\n\n![Github](../attachments/raycast-2022-08-16-11-29-24.png)\n\n## Gitignore\n\n[다운로드 링크](https://www.raycast.com/daniel-stoneuk/gitignore)\n\nhttps://www.toptal.com/developers/gitignore/  \n\n위 링크에서 제공해주는 기능을 그대로 제공한다.  \n선택한 ignore 프로그램을 기반으로 .gitignore 를 만들어 클립보드에 복사해준다.  \n\n프로젝트 초반에 가끔 이용할 것 같다.\n\n![Gitignore](../attachments/raycast-2022-08-16-13-34-54.png)\n\n## Google Chrome\n\n[다운로드 링크](https://www.raycast.com/Codely/google-chrome)\n검색 히스토리나 열려있는 탭들이 뭐가 있는지 검색할 수 있는 기능을 제공한다.  \n개발을 하다보면 열린 탭들이 많아질때가 있는데 이때 탭이동을 수월할게 할 수 있다.\n\n![Google Chrome](../attachments/raycast-2022-08-16-13-38-36.png)\n\n## Google Chrome Profile\n\n[다운로드 링크](https://www.raycast.com/frouo/google-chrome-profiles)\n\n회사 계정과 개인 구글 워크스페이스 계정이 분리되어 있거나, 개발하고 있는 서비스의 권한 별로 QA 를 진행하다보면, 크롬에 여러 구글 Profile 이 연결되어 있는 경우가 있는데, 이때 사용하면 좋다.\n특정 Profile 을 선택해, 접속하고자 하는 주소를 입력하면 된다.\n\n![Google Chrome Profile](../attachments/.raycast_images/CleanShot%202023-10-23%20at%2010.png)\n\n## Google Translate\n\n[다운로드 링크](https://www.raycast.com/gebeto/translate)\n\n자주 사용하는 언어 두가지를 등록해두면 두 언어 사이의 번역을 편하게 해주는 기능이다.\n\n![Google Translate](../attachments/raycast-2022-08-16-13-40-03.png)\n\n## Google Workspace\n\n[다운로드 링크](https://www.raycast.com/raycast/google-workspace)\n\nGoogle workspace 에서 제공하는 문서를 생성하고, 검색할 수 있는 기능을 제공한다.  \n사내 공유된 문서를 검색할 때 사용하려고 했지만, 현재 드라이브에 공유된 파일만 검색이 되고 있어 사용이 불편하긴하다.  \n관련해서 공유된 문서들도 검색이 되도록하는 Pull Request 가 올라가 있으니 기다리면 지원이 될 것 같다.\n\n![Google Workspace](../attachments/raycast-2022-08-16-13-43-42.png)\n\n## Jira\n\n[다운로드 링크](https://www.raycast.com/raycast/jira)\n\nJira 테스크 관리 기능을 제공한다. 특히 티켓 생성 기능이 편리하다.\n\n![Jira](../attachments/raycast-2022-08-16-13-57-13.png)\n\n## Git Repos\n[다운로드 링크](https://www.raycast.com/moored/git-repos)\n\n등록해놓은 Path 하위에 있는 .git 디렉토리를 전부 찾아준다. \n\n![](../attachments/raycast-2022-08-16-14-21-32.png)\n\n추가로 사용하는 IDE 나 터미널로 여는 기능이나, 해당 git repo 의 origin 을 여는 기능또한 지원한다. `cmd + shift + o`  \n![](../attachments/raycast-2022-08-16-14-02-43.png)\n\n## Session\n[다운로드 링크](https://www.raycast.com/jameslyons/session)\n\n평소 업무나 개인 공부를 할때 Session 앱을 자주 사용하는데 플러그인이 있어 설치했다.\n\nsession 을 시작하거나 끝낼 수 있는 동작을 지원한다.\n\n![](../attachments/raycast-2022-08-21-21-57-05.png)\n\n## Window Management\n\n기존에 Spectacle 툴을 사용하여 원도우를 관리했었는데, raycast 에서도 동일한 기능을 지원한다.  \n유사한 툴로는 Magnet, Spectacle 등등이 있다.\n\n![](../attachments/![](../attachments/raycast-2022-08-21-21-58-19.png).png)\n\n## Terminal Finder\n\n[다운로드 링크](https://www.raycast.com/yedongze/terminalfinder)  \nIterm 에서 해당 경로로 Finder 를 열거나, Finder 에서 Iterm 을 열 수 있게 해준다.\n\n![](../attachments/raycast-2022-08-21-22-01-11.png)\n\n## Port Manager\n\n[다운로드 링크](https://www.raycast.com/lucaschultz/port-manager)\n\nmac 을 사용하면서 가장 많이 검색하는 키워드중에 하나가 \"mac kill port\" 일 것이다.  \n해당 플러그인을 사용하면 현재 열려있는 포트 리스트와 특정 포트를 kill 하는 인터페이스를 제공한다.\n\n![Port Manager](../attachments/raycast-2022-08-21-22-03-45.png)\n\n## Slack\n[다운로드 링크](https://www.raycast.com/mommertf/slack#readme)\n\n회사에서 메신저로 Slack 를 사용하고 있다면 유용하다.\n반드시 확인해야하는 메세지나 채널 (페이지 모니터링 채널 등...) 은 `Unread Messages` 에 채널을 등록해서 수시로 확인하고,\n\n`Open Unread Messages` 를 단축키로 등록해, 포모도로가 한 세션 끝날때 마다 확인하고 있다.\n\n![Slack](../attachments/raycast-2022-08-21-22-52-38.png)\n\n## ray.so\n[다운로드 링크](https://www.raycast.com/garrett/ray-so)\n\n소스 코드를 이미지화 해준다. 비슷한 사이트로는 [Carbon](https://carbon.now.sh) 이라는 웹사이트가 있다.  \n이미지화 할 소스코드에 드래그해서 커서를 만든 후, `Create Image From Code` 를 선택하면 된다.  \n아래는 해당 실행의 결과물이다.\n\n![ray.so](../attachments/603f613c8cf57b98b81b6176834b1043.png)\n\n## Lorem Ipsum  \n[다운로드 링크](https://www.raycast.com/AntonNiklasson/lorem-ipsum)\n\n가끔 lorem 이 필요할 때 가볍게 사용할 수 있다.\n\n![Lorem Ipsum](../attachments/.raycast_images/CleanShot 2023-10-23 at 10.png)\n\n## Figma file search\n[다운로드 링크](https://www.raycast.com/michaelschultz/figma-files-raycast-extension)\n\n회사에서 Figma 를 디자인 툴로 사용하고 있다면 유용하다. 프로젝트 검색 및 최근 수정한 파일에 쉽게 접근할 수 있다.\n![Figma file search](../attachments/.raycast_images/7bb73211.png)\n"},{"fields":{"slug":"/tips/strapi/","title":"Strapi"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Strapi\ntags:\n  - strapi\n---\n\n## 참고 링크\n[코딩 없이 10분 만에 REST API/Graphql 서버 개발하기](https://medium.com/@khwsc1/js%EB%A1%9C-10%EB%B6%84%EB%A7%8C%EC%97%90-rest-api-graphql-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0-d28148dbdef2)\n\n[🐳 Docker with Strapi V4 🌟](https://blog.dehlin.dev/docker-with-strapi-v4)\n\n[User Authentication in Next.js with Strapi](https://strapi.io/blog/user-authentication-in-next-js-with-strapi)\n\n\n[Google Cloud Console](https://console.cloud.google.com/apis/credentials)"},{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"}]}}}