---
title: Five Lines of Code
tags:
  - 책읽기
---

## 3장. 긴 코드 조각 내기

### DRY 및 KISS 지침들이 어려웠던 이유
- 메서드가 여러가지 다른 일을 수행한다.
- 낮은 수준의 원시 연산을 사용한다.
- 주석과 적절한 메서드와 변수명 같이 사람이 읽을 수 있는 텍스트가 부족하다.

### 왜 다섯 줄인가?
정의: 메서드는 `{` 와 `}` 를 제외하고 5줄 이상이 되어서는 안 된다.

모든 메서드를 이 규칙을 준수하도록 바꿀 수 있다.

**스멜**  
메서드가 길다는 것 자체가 스멜이다. 긴 메서드의 모든 논리를 머릿속에 담아야해서 작업하기가 어렵다. 

**의도**  
시간이 지남에 따라 추가되는 기능들로 인해 메서드가 커지는 경향이 있다. 5줄의 코드가 있는 4개의 메서드가 20줄인 하나의 메서드보다 훨씬 빠르고 이해하기 쉽다.

코드를 이해하기 위한 첫 번째 단계는 **항상 함수명을 고려하는 것**  

### 리펙터링: 메서드 추출
메서드를 더 작은 조각으로 분해하는 리팩터링 기법이다.

- 원하는 이름으로 새로운 빈 메서드 생성
- 그룹의 맨 위에서 새로운 메서드 호출
- 그룹의 코드를 잘라내어 새로운 메서드의 본문에 붙여 넣기
- 컴파일
- 메개변수를 도입하여 호출하는 쪽의 오류를 발생시키기
- 매개변수 중 하나를 반환값으로 할당해야 할 경우: 
  - 새로운 메서드의 마지막에 반환값을 추가
  - 새로운 메서드를 호출하는 쪽에서 반환값을 할당
- 컴파일
- 호출쪽 인자 셋팅
- 사용하지 않는 코드와 주석 제거

이 절차는 아무것도 손상시키지 않는다. 코드가 수행하는 작업을 아직 살펴보지 않는 경우에는 아무것도 고장내지 않았다는 확신이 가장 중요함

### 규칙: 호출 또는 전달, 한 가지만 할 것  
함수 내에서는 객체에 있는 메서드를 호출하거나 객체를 인자로 전달할 수 있지만 둘을 섞어 사용해서는 안된다.  
많은 메서드 및 여러 가지 매개변수를 전달하는 경우, 결국 해당 함수의 책임이 고르지 않게 될 수 있다.  

```ts
function average(arr: number[]) {
  return sum(arr) / arr.length
}


function average(arr: number[]) {
  return sum(arr) / size(arr)
}
```
위 함수는 높은 수준의 추상화와 낮은 수준의 arr.length 를 모두 사용

**스멜**  
함수의 내용은 동일한 추상화 수준에 있어야 한다. 전달된 인자의 메서드가 어떻게 사용되는지 식별하는 방ㄹ법은 인자로 전달된 변수 옆의 `.` 을 통해 찾을 수 있다. 

**의도**  
메서드에서 몇 가지 세부적인 부분을 추출해서 추상화를 도입할 때 연관된 다른 세부적인 부분도 추출하게 한다. 이러면 메서드 내부의 추상화 수준이 항상 동일하게 유지  
> 함수의 내용은 동일한 추상화 수준에 있어야 한다.

### 좋은 함수의 이름의 속성
- 정직해야 한다. 함수의 의도를 설명해야 한다. 
- 완전해야 한다. 함수가 하는 모든 것을 담아야 한다.
- 도메인에서 일하는 사람이 이해할 수 있어야 한다. 

> 함수명을 지을 때는 항상 나중에 함수가 더 작아졌을 때 이름을 개선할 수 있는지를 평가해 봐야한다. 

### 규칙: if 문은 함수의 시작에만 배치
if 문이 있는 경우 해당 if 문은 함수의 첫번째 항목이어야 한다.  
함수는 한 가지 일만 해야 한다. 무언가를 확인하는 것은 한가지 일 즉 if 가 있는 경우 함수의 첫번째 항목이어야 하고, 그 후에는 아무것도 해서는 안된다.  
if 문을 분리하가 위해 메서드 추출을 사용한다.  

```ts
function reportPrimes(n: number) {
  for (let i = 2; i < n; i++) {
    if (isPrime(i)) {
      console.log(`${i} is prime`);
    }
  }
}


function reportPrimes(n: number) {
  for (let i = 2; i < n; i++) {
    reportIfPrime(i);
  }
}

function reportIfPrime(n: number) {
  if (isPrime(i)) {
    console.log(`${i} is prime`);
  }
}
```

**스멜**  
다섯 줄 제한과 같이 이 규칙은 함수가 한가지 이상의 작업을 수행하는 스멜을 막기 위해 존재

**의도**  
if 문이 하나의 작업이기 때문에 이를 분리할 때 이어지는 else if 는 if 문과 분리할 수 없는 원자 단위로 봄

## 4장. 타입 코드 처리하기

### 규칙: if 문에서 else 를 사용하지 말 것

프로그램에서 이해하지 못하는 타입인지를 검사하지 않는 한 if 문에서 else 를 사용하지 않는다.

`if-else` 를 사용하면 코드에서 결정이 내려지는 지점을 고정하게 된다.

독립된 if 문은 검사로 간주하고, if-else 문은 의사 결정으로 간주한다.

```ts
// AS IS
function average(ar: number[]) {
  if (size(ar) === 0) {
    throw new Error("Cannot take average of empty array");
  }
  return sum(ar) / size(ar);
}

// TO BE
function average(ar: number[]) {
  assertNotEmpty(ar);
  return sum(ar) / size(ar);
}

function assertNotEmpty(ar: number[]) {
  if (size(ar) === 0) {
    throw new Error("Cannot take average of empty array");
  }
}
```

**스멜**  
이른 바인딩: if-else 같은 의사결정 동작은 컴파일 시 처리되어 애플리케이션에 고정되면 재컴파일 없이는 수정할 수 없다.  
늦은 바인딩:  코드가 실행되는 순간 동작이 결정됨

**의도**  
if 는 흐름을 제어 -> 다음에 실행할 코드를 결정한다는 뜻  

### 리펙터링: 클래스로 타입 코드 대체
열거형을 인터페이스로 변환하고 열거형의 값들을 클래스가 되도록 변환한다.  
해당 리펙터링 패턴은 자체적으로 많은 가치를 가지지 않지만, 추후 개선을 가능하기 한다.

### 리펙터링: 클래스로 코드 이관하기  
기능을 클래스로 옮기면서 클래스로 타입 코드 대체 패턴의 자연스러운 연장선  
특정 값과 연결된 기능이 값에 해당하는 클래스로 이동하기 때문에 불변속성을 지역화  

### 리펙터링: 메서드의 인라인화 
프로그앰에서 더 이상 가독성에 도움이 되지 않는 메서드를 제거   
단, 메서드를 인라인으,로 사용하는 것과는 다른 개념  

메서드가 인라인화 하기 너무 복잡한가 -> 낮은 수준의 연산에 의존하여 가독성에 도움이 되는 경우에는 인라인화하지 않는다.  

### 리펙터링: 메서드 전문화  
일반화하고 재사용하려는 본능적인 욕구가 있지만 그렇게 하면 책임이 흐려지고, 다양한 위치에서 코드를 호출할 수 있기 때문에 문제가 될 수 있음  
전문화된 메서드는 더 적은 위치에서 호출되어 필요성이 없어지면 더 쉽게 제거 가능함  

### 규칙: switch 를 사용하지 말것
default 케이스가 없고 모든 case 에 반환값이 존재하는 경우에는 switch 를 사용하지 않는다.

**switch 의 문제점**
- 컴파일러 입장에서 새로 추가한값의 처리에 대한 누락을 알 수 없다.
- break 키워드 누락으로 인한 버그

**스멜**  
switch 문은 값을 처리하는 방법에 초점, 클래스에 기능을 추가할때는 값이 상황을 처리하는 방법에 초점  
컨텍스트에 초점을 맞춘다는 것은 불변속성을 전역화하는 것을 의미  

**의도**  
switch -> else if -> 클래스로 변환

### 인터페이스 대신 추상 클래스를 사용할 수 없을까?  
사용할 수 있다. 코드의 중복을 피할 수 있다.   
하지만 인터페이스를 사용하면 개발자가 능동적으로 무엇인가를 해야함. 즉, 누락으로 인한 오류를 방지할 수 있음

### 규칙: 인터페이스에서만 상속받을 것  
상속은 오직 인터페이스를 통해서만 받는다.  

추상 클래스를 사용하는 것은 일부 메서드의 기본 구현을 제공하고, 다른 메서드를 추상화 하기 위함 -> 중복을 줄이고 코드의 줄을 줄이고자 할 경우 편리  
하지만 추상 클래스의 코드 공유는 커플링을 유발하고, 기본 구현으로 인해 재정의가 필요한 메서드 인지 컴파일러를 통해 확인이 어려움 

**스멜**  
> 상속보다는 컴포지션이 더 좋다 <<GoF의 디자인 패턴>>  

### 리팩터링: 삭제 후 컴파일하기
인터페이스에서 사용하지 않는 메서드를 제거하는 것  
메서드를 삭제하고 컴파일러에서 허용하는지 확인하는 것  

## 5장. 유사한 코드 융합하기  

### 리팩터링: 유사 클래스 통합  
일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서 일련의 상수 메서드가 클래스에 따라 다른 값을 반환할 때 클래스를 통합할 수 있다.   

### 리펙터링: if 문 결합



